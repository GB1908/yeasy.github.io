<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html lang="en">
	<head>
		<title>Paper List</title>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		
		<script type="text/javascript">
			<!--
				// QuickSearch script for JabRef HTML export 
				// Version: 3.0
				//
				// Copyright (c) 2006-2008, Mark Schenk
				// Copyright (c) 2009, Holger Jeromin <jeromin(at)plt.rwth-aachen.de>, Chair of Process Control Engineering, Aachen University of Technology
				//
				// This software is distributed under a Creative Commons Attribution 3.0 License
				// http://creativecommons.org/licenses/by/3.0/
				
				// Some features:
				// + optionally searches Abstracts and Reviews
				// + allows RegExp searches
				//   e.g. to search for entries between 1980 and 1989, type:  198[0-9]
				//   e.g. for any entry ending with 'symmetry', type:  symmetry$
				//   e.g. for all reftypes that are books: ^book$, or ^article$
				//   e.g. for entries by either John or Doe, type john|doe
				// + easy toggling of Abstract/Review/BibTeX
				
				// Features from Holger Jeromin
				// + incremental search in each column (input or dropdownbox)
				// + global search can search with multiple search words in the row
				//   global search of special regexp related to a cell is not possible anymore: ^2009$
				//   but this is possible in the local searches
				// + use of innerText/textContent for less function overhead
				
				// Search settings
				var searchAbstract = true;
				var searchReview = true;
				
				if (window.addEventListener) {
					window.addEventListener("load",initSearch,false); }
				else if (window.attachEvent) {
					window.attachEvent("onload", initSearch); }
				
				function initSearch() {

					// basic object detection
					if(!document.getElementById || !document.getElementsByTagName) { return; }
					if (!document.getElementById('qstable')||!document.getElementById('qs')) { return; }
				
					// find QS table and appropriate rows
					searchTable = document.getElementById('qstable');
					var allRows = searchTable.getElementsByTagName('tbody')[0].getElementsByTagName('tr');
				
					// split all rows into entryRows and infoRows (e.g. abstract, review, bibtex)
					entryRows = new Array();
					infoRows = new Array(); absRows = new Array(); revRows = new Array();
				
					for (var i=0, k=0, j=0; i<allRows.length;i++) {
						if (allRows[i].className.match(/entry/)) {
							entryRows[j++] = allRows[i];
						} else {
							infoRows[k++] = allRows[i];
							// check for abstract/review
							if (allRows[i].className.match(/abstract/)) {
								absRows.push(allRows[i]);
							} else if (allRows[i].className.match(/review/)) {
								revRows.push(allRows[i]);
							}
						}
					}
				
					//number of entries and rows
					numRows = allRows.length;
					numEntries = entryRows.length;
					numInfo = infoRows.length;
					numAbs = absRows.length;
					numRev = revRows.length;
				
					//find the query field
					qsfield = document.getElementById('qsfield');
				
					//find statistics location
					stats = document.getElementById('stat');
					setStatistics(-1);
				
					// creates the appropriate search settings
					createQSettingsDialog();
				
					// shows the searchfield
					document.getElementById('qs').style.display = 'block';
					qsfield.onkeyup = testEvent;
					qsfield.onchange = testEvent;
				}
				
				function quickSearch(tInput){
				
					var localSearchArray = new Array();
					var globalSearchText = null;
					var globalSearch = new Array();
					// only search for valid RegExp
					//this input is in the global field and the user has typed something in
					if (qsfield == tInput && tInput.value != ""){
						//clear all other search fields
						for(var i=0; i<tableheaders.length; i++) {
							if (tableheaders[i].lastChild.nodeName == "INPUT"){
								tableheaders[i].lastChild.value = "";
							}else if (tableheaders[i].lastChild.nodeName == "SELECT"){
								tableheaders[i].lastChild.selectedIndex = 0;
							}
							tableheaders[i].lastChild.className = '';
						}
						try {
							globalSearchText = qsfield.value.split(" ");
							for (var i = 0; i < globalSearchText.length; i++){
								if (globalSearchText[i]){
									globalSearch[i] = new RegExp(globalSearchText[i],"i");
								}
							}
						}catch(err) {
							tInput.className = 'invalidsearch';
							if (window.console != null){
								window.console.error("Search Error: %s", err);
							}
							return;
						}
					//this input is a local search => clear the global search
					}else if (tInput.value != ""){
						qsfield.value = "";
					}
					closeAllInfo();
					qsfield.className = '';
					for(var i=0; i<tableheaders.length; i++) {
						if (tableheaders[i].lastChild.value != ""){
							try {
								if(searchSubString[i] == true){
									localSearchArray[i] = new RegExp(tableheaders[i].lastChild.value,"i")
								}else{
									localSearchArray[i] = new RegExp("^"+tableheaders[i].lastChild.value+"$","i")
								}
							}catch(err) {
								tableheaders[i].lastChild.className = 'invalidsearch';
								if (window.console != null){
									window.console.error("Search Error: %s", err);
								}
								return;
							}
						}
						tableheaders[i].lastChild.className = '';
					}
					
					// count number of hits
					var hits = 0;
					//initialise variable
					var t;
					var inCells;
					var numCols;
					
					// start looping through all entry rows
					for (var i = 0; cRow = entryRows[i]; i++){
						var found = false; 
						
						if (globalSearch.length == 0 && localSearchArray.length == 0){ 
							//no search selected
							found=true;
						}else if (globalSearch.length != 0){
							t = undefined != cRow.innerText?cRow.innerText:cRow.textContent;
							for (var k = 0; k < globalSearch.length; k++){
								if (t.search(globalSearch[k]) == -1){ 
									found=false;
									break;
								}else{
									found=true;
								}
							}
						}else{
							inCells = cRow.getElementsByTagName('td');
							numCols = inCells.length;
							for (var j=0; j<numCols; j++) {
								if (undefined != localSearchArray[j]){
									cCell = inCells[j];
									t = undefined != cCell.innerText?cCell.innerText:cCell.textContent;
									if (t.search(localSearchArray[j]) == -1){
										found=false;
										break;
									}else{
										found=true;
									}
								}
							}
						}
						// look for further hits in Abstract and Review
						if(!found) {
							var articleid = cRow.id;
							if(searchAbstract && (abs = document.getElementById('abs_'+articleid))) {
								for (var k = 0; k < globalSearch.length; k++){
									if ((undefined != abs.innerText?abs.innerText:abs.textContent).search(globalSearch[k]) == -1){ 
										found=false;
										break;
									}else{
										found=true;
									}
								}
							}
							if(searchReview && (rev = document.getElementById('rev_'+articleid))) {
								for (var k = 0; k < globalSearch.length; k++){
									if ((undefined != rev.innerText?rev.innerText:rev.textContent).search(globalSearch[k]) == -1){ 
										found=false;
										break;
									}else{
										found=true;
									}
								}
							}
							articleid = null;
						}
						
						if(found) {
							cRow.className = 'entry show';
							hits++;
						} else {
							cRow.className = 'entry noshow';
						}
					}
					
					// update statistics
					setStatistics(hits)
				}
				
				function toggleInfo(articleid,info) {
					var entry = document.getElementById(articleid);
					var abs = document.getElementById('abs_'+articleid);
					var rev = document.getElementById('rev_'+articleid);
					var bib = document.getElementById('bib_'+articleid);
					
					// Get the abstracts/reviews/bibtext in the right location
					// in unsorted tables this is always the case, but in sorted tables it is necessary. 
					// Start moving in reverse order, so we get: entry, abstract,review,bibtex
					if (searchTable.className.indexOf('sortable') != -1) {
						if(bib) { entry.parentNode.insertBefore(bib,entry.nextSibling); }
						if(rev) { entry.parentNode.insertBefore(rev,entry.nextSibling); }
						if(abs) { entry.parentNode.insertBefore(abs,entry.nextSibling); }
					}
				
					if (abs && info == 'abstract') {
						if(abs.className.indexOf('abstract') != -1) {
						abs.className.indexOf('noshow') == -1?abs.className = 'abstract noshow':abs.className = 'abstract';
						}
					} else if (rev && info == 'review') {
						if(rev.className.indexOf('review') != -1) {
						rev.className.indexOf('noshow') == -1?rev.className = 'review noshow':rev.className = 'review';
						}
					} else if (bib && info == 'bibtex') {
						if(bib.className.indexOf('bibtex') != -1) {
						bib.className.indexOf('noshow') == -1?bib.className = 'bibtex noshow':bib.className = 'bibtex';
						}		
					} else { 
						return;
					}
				
					// check if one or the other is available
					var revshow = false;
					var absshow = false;
					var bibshow = false;
					(abs && abs.className.indexOf('noshow') == -1)? absshow = true: absshow = false;
					(rev && rev.className.indexOf('noshow') == -1)? revshow = true: revshow = false;	
					(bib && bib.className == 'bibtex')? bibshow = true: bibshow = false;
					
					// highlight original entry
					if(entry) {
						if (revshow || absshow || bibshow) {
						entry.className = 'entry highlight show';
						} else {
						entry.className = 'entry show';
						}		
					}
					
					// When there's a combination of abstract/review/bibtex showing, need to add class for correct styling
					if(absshow) {
						(revshow||bibshow)?abs.className = 'abstract nextshow':abs.className = 'abstract';
					} 
					if (revshow) {
						bibshow?rev.className = 'review nextshow': rev.className = 'review';
					}
					
				}
				
				function setStatistics (hits) {
					if(hits < 0) { hits=numEntries; }
					if(stats) { stats.firstChild.data = hits + '/' + numEntries}
				}
				
			
				function showAll(){
					// first close all abstracts, reviews, etc.
					closeAllInfo();
				
					for (var i = 0; i < numEntries; i++){
						entryRows[i].className = 'entry show'; 
					}
				}
				
				function closeAllInfo(){
					for (var i=0; i < numInfo; i++){
						if (infoRows[i].className.indexOf('noshow') ==-1) {
							infoRows[i].className = infoRows[i].className + ' noshow';
						}
					}
				}
				
				function testEvent(e){
					if (!e) var e = window.event;
					quickSearch(this);
				}
				
				function clearQS() {
					qsfield.value = '';
					for(var i=0; i<tableheaders.length; i++) {
						if (tableheaders[i].lastChild.nodeName == "INPUT"){
							tableheaders[i].lastChild.value = "";
						}else if (tableheaders[i].lastChild.nodeName == "SELECT"){
							tableheaders[i].lastChild.selectedIndex = 0;
						}
						//get rid of error color
						tableheaders[i].lastChild.className = '';
					}
					quickSearch(qsfield);
				}
				
				function redoQS(){
					showAll();
					quickSearch(qsfield);
				}
				
				// Create Search Settings
				function toggleQSettingsDialog() {
				
					var qssettings = document.getElementById('qssettings');
					
					if(qssettings.className.indexOf('active')==-1) {
						qssettings.className = 'active';
				
						if(absCheckBox && searchAbstract == true) { absCheckBox.checked = 'checked'; }
						if(revCheckBox && searchReview == true) { revCheckBox.checked = 'checked'; }
				
					} else {
						qssettings.className= '';
					}
				}
				
				function createQSettingsDialog(){
					var qssettingslist = document.getElementById('qssettings').getElementsByTagName('ul')[0];
					
					if(numAbs!=0) {
						var x = document.createElement('input');
						x.id = "searchAbs";
						x.type = "checkbox";
						x.onclick = toggleQSetting;
						var y = qssettingslist.appendChild(document.createElement('li')).appendChild(document.createElement('label'));
						y.appendChild(x);
						y.appendChild(document.createTextNode('search abstracts'));		
					}
					if(numRev!=0) {
						var x = document.createElement('input');
						x.id = "searchRev";
						x.type = "checkbox";		
						x.onclick = toggleQSetting;
						var y = qssettingslist.appendChild(document.createElement('li')).appendChild(document.createElement('label'));		
						y.appendChild(x);		
						y.appendChild(document.createTextNode('search reviews'));
					}
						
					// global variables
					absCheckBox = document.getElementById('searchAbs');
					revCheckBox = document.getElementById('searchRev');
					
					// show search settings
					if(absCheckBox||revCheckBox) {
						document.getElementById('qssettings').style.display = 'block';
					}
				}
				
				function toggleQSetting() {
					if(this.id=='searchAbs') { searchAbstract = !searchAbstract; }
					if(this.id=='searchRev') { searchReview = !searchReview; }
					redoQS()
				}
			-->
		</script>
		<script type="text/javascript">
		<!--
		// Automagically create a dropdown box for column heades marked with the 'dropd' class
		// Mostly useful for year / BibTeX-type fields
		
		if (window.addEventListener) {
			window.addEventListener("load",populateSelect,false) }
		else if (window.attachEvent) {
			window.attachEvent("onload",populateSelect); }
		
		function populateSelect() {
			// find the column with the dropdowns
			var searchTable = document.getElementById('qstable');
			tableheaders = searchTable.getElementsByTagName('thead')[0].getElementsByTagName('th');
			var allRows = searchTable.getElementsByTagName('tbody')[0].getElementsByTagName('tr');
			//initialise variables
			var interactionelement;
			var brelement;
			var selectlist;
			var colsinrow;
			var entryContent;
			var usedentries;
			searchSubString = new Array(tableheaders.length);
		
			for(var i=0; i<tableheaders.length; i++) {
				if(tableheaders[i].className=="input") {
					interactionelement = document.createElement('input');
					interactionelement.type = "text";
					interactionelement.size = 10;
					interactionelement.autocomplete = "off";
					interactionelement.onkeyup = testEvent;
					interactionelement.onchange = testEvent;
					searchSubString[i] = true;
				}else if(tableheaders[i].className=="dropd") {
					selectlist = new Array();
					for(var k=0; k<allRows.length; k++) {
						colsinrow = allRows[k].getElementsByTagName('td');
						if(colsinrow.length >= i) {
							entryContent = undefined != colsinrow[i].innerText?colsinrow[i].innerText:colsinrow[i].textContent;
							//avoid empty entrys
							if ("" != entryContent && undefined != entryContent){
								selectlist.push(entryContent);
							}
						}
					}
					// sort the entry array
					selectlist.sort();
					
					//clear duplicate entrys
					usedentries = new Array();
					usedentries.push(selectlist[0]);
					for(j=1; j<selectlist.length;j++) {
						if(selectlist[j]!= selectlist[j-1]) {
							usedentries.push(selectlist[j]);
						}
					}
					//create select Element
					interactionelement = document.createElement('select');
					//create descriptive first Element
					interactionelement.appendChild(document.createElement('option'));
					interactionelement.lastChild.appendChild(document.createTextNode('- all -'));
					interactionelement.lastChild.value = "";
					//create all Elements
					for(k=0; k<usedentries.length; k++) {
						interactionelement.appendChild(document.createElement('option'));
						interactionelement.lastChild.value = usedentries[k];
						interactionelement.lastChild.appendChild(document.createTextNode(usedentries[k]));
					}
					interactionelement.onchange = testEvent;
					searchSubString[i] = false;
				}
				//prevent clicking in the element start sorting the table
				interactionelement.onclick = cancelBubble;
				brelement = document.createElement('br');
				tableheaders[i].appendChild(brelement);
				tableheaders[i].appendChild(interactionelement);
			}
		}
		
		function cancelBubble(e){
			if (!e) var e = window.event;
			e.cancelBubble = true;
			if (e.stopPropagation) e.stopPropagation();	
		}
		function resetFilter(){
			var typeselect = document.getElementById('reftypeselect');
			typeselect.selectedIndex = 0;
		}
		
		-->
		</script>
<script type="text/javascript">
<!--
// Sort Table Script
// Version: 1.1
//
// Copyright (c) 2006-2008, Mark Schenk
// Copyright (c) 2009, Holger Jeromin <jeromin(at)plt.rwth-aachen.de>, Chair of Process Control Engineering, Aachen University of Technology

// Features from Holger Jeromin
// + use of innerText/textContent for less function overhead
// + search optimisation (only search in cell.firstchild) deactivated, firefox is fast enough with the use of textContent

// This software is distributed under a Creative Commons Attribution 3.0 License
// http://creativecommons.org/licenses/by/3.0/

// Sorting of columns with a lot of text can be slow, so some speed optimizations can be enabled,
// using the following variable
var SORT_SPEED_OPT = false;
// the optimization has one limitation on the functionality: when sorting search
// results, the expanded info, e.g. bibtex/review, is collapsed. In the non-optimized
// version they remain visible.

if (window.addEventListener) {
	window.addEventListener("load",initSortTable,false) }
else if (window.attachEvent) {
	window.attachEvent("onload", initSortTable); }

function initSortTable() {
	var alltables = document.getElementsByTagName('table');
	for(i=0;i<alltables.length;i++) {
		var currentTable = alltables[i];
		if(currentTable.className.indexOf('sortable') !=-1) {
			var thead = currentTable.getElementsByTagName('thead')[0];
			thead.title = 'Click on any column header to sort';
			for (var i=0;cell = thead.getElementsByTagName('th')[i];i++) {
				cell.onclick = function () { resortTable(this); };
				// make it possible to have a default sort column
				if(cell.className.indexOf('sort')!=-1) {
					resortTable(cell)
				}
			}
		}
	}
}

var SORT_COLUMN_INDEX;

function resortTable(td) {
	var column = td.cellIndex;
	var table = getParent(td,'TABLE');

	var allRows = table.getElementsByTagName('tbody')[0].getElementsByTagName('tr');
	var newRows = new Array();

	for (var i=0, k=0; i<allRows.length;i++) {

		var rowclass = allRows[i].className;

		if (rowclass.indexOf('entry') != -1) {
			newRows[k++] = allRows[i];
		}
		
		if (SORT_SPEED_OPT) {
			// remove highlight class
			allRows[i].className = rowclass.replace(/highlight/,'');
			// close information
			if(rowclass.indexOf('entry') == -1 && rowclass.indexOf('noshow') == -1) { allRows[i].className = rowclass + ' noshow';}
		}
	}

	// If other sort functions are deemed necessary (e.g. for
	// dates and currencies) they can be added.
	var sortfn = ts_sort_caseinsensitive;
	SORT_COLUMN_INDEX = column;
	newRows.sort(sortfn);

	// create a container for showing sort arrow
	var arrow =  td.getElementsByTagName('span')[0];
	if (!arrow) { var arrow = td.insertBefore(document.createElement('span'), td.childNodes[1]);}
	
	if (td.className) {
		if (td.className.indexOf('sort_asc') !=-1) {
			td.className = td.className.replace(/_asc/,"_des");
			newRows.reverse();
			arrow.innerHTML = ' &uarr;';
		} else if (td.className.indexOf('sort_des') !=-1) {
			td.className = td.className.replace(/_des/,"_asc");
			arrow.innerHTML = ' &darr;';
		} else { 
			td.className += ' sort_asc'; 
			arrow.innerHTML = ' &darr;';
		}
	} else {
		td.className += 'sort_asc';
		arrow.innerHTML = ' &darr;';
	}
	
	// Remove the classnames and up/down arrows for the other headers
	var ths = table.getElementsByTagName('thead')[0].getElementsByTagName('th');
	for (var i=0; i<ths.length; i++) {
		if(ths[i]!=td && ths[i].className.indexOf('sort_')!=-1) {
		// argh, moronic JabRef thinks (backslash)w is an output field!!
		//ths[i].className = ths[i].className.replace(/sort_(backslash)w{3}/,"");
		ths[i].className = ths[i].className.replace(/sort_asc/,"");
		ths[i].className = ths[i].className.replace(/sort_des/,"");

		// remove span
		var arrow =  ths[i].getElementsByTagName('span')[0];
		if (arrow) { ths[i].removeChild(arrow); }
		}
	}

	// We appendChild rows that already exist to the tbody, so it moves them rather than creating new ones
	for (i=0;i<newRows.length;i++) { 
		table.getElementsByTagName('tbody')[0].appendChild(newRows[i]);

		if(!SORT_SPEED_OPT){
		// moving additional information, e.g. bibtex/abstract to right locations
		// this allows to sort, even with abstract/review/etc. still open
		var articleid = newRows[i].id;

		var entry = document.getElementById(articleid);
		var abs = document.getElementById('abs_'+articleid);
		var rev = document.getElementById('rev_'+articleid);
		var bib = document.getElementById('bib_'+articleid);		
	
		var tbody = table.getElementsByTagName('tbody')[0];
		// mind the order of adding the entries
		if(abs) { tbody.appendChild(abs); }
		if(rev) { tbody.appendChild(rev); }
		if(bib) { tbody.appendChild(bib); }
		}
	}
}


function ts_sort_caseinsensitive(a,b) {
	aa = (undefined != a.cells[SORT_COLUMN_INDEX].innerText?a.cells[SORT_COLUMN_INDEX].innerText:a.cells[SORT_COLUMN_INDEX].textContent).toLowerCase();
	bb = (undefined != b.cells[SORT_COLUMN_INDEX].innerText?b.cells[SORT_COLUMN_INDEX].innerText:b.cells[SORT_COLUMN_INDEX].textContent).toLowerCase();
	if (aa==bb) return 0;
	if (aa<bb) return -1;
	return 1;
}

function ts_sort_default(a,b) {
	aa = (undefined != a.cells[SORT_COLUMN_INDEX].innerText?a.cells[SORT_COLUMN_INDEX].innerText:a.cells[SORT_COLUMN_INDEX].textContent);
	bb = (undefined != b.cells[SORT_COLUMN_INDEX].innerText?b.cells[SORT_COLUMN_INDEX].innerText:b.cells[SORT_COLUMN_INDEX].textContent);
	if (aa==bb) return 0;
	if (aa<bb) return -1;
	return 1;
}

function getParent(el, pTagName) {
	if (el == null) { 
		return null;
	} else if (el.nodeType == 1 && el.tagName.toLowerCase() == pTagName.toLowerCase()) {
		return el;
	} else {
		return getParent(el.parentNode, pTagName);
	}
}
-->
</script>
		<style type="text/css">
			body { background-color: white; font-family: "Trebuchet MS", Arial, sans-serif; font-size: 12px; line-height: 1.2; padding: 1em; color: #2E2E2E; }
			
			#qs { width: auto; border-style: solid; border-color: gray; border-width: 1px 1px 0px 1px; padding: 0.5em 0.5em; display:none; position:relative; }
			#qs form { padding: 0px; margin: 0px; }
			#qs form p { padding: 0px; margin: 0px; }
			
			.invalidsearch { background-color: red; }
			
			table { border: 1px gray solid; width: 100%; empty-cells: show; }
			th, td { border: 1px gray solid; padding: 0.5em; vertical-align: top;  }
			td { text-align: left; vertical-align: top; }
			th { background-color: #EFEFEF; }
			
			td a { color: navy; text-decoration: none; }
			td a:hover  { text-decoration: underline; }
			
			tr.noshow { display: none;}
			
			tr.highlight td { background-color: #F1F1F1; border-top: 2px black solid; font-weight: bold; }
			tr.abstract td, tr.review td, tr.bibtex td { background-color: #F1F1F1; border-bottom: 2px black solid; }
			tr.nextshow td { border-bottom: 1px gray solid; }
			
			tr.bibtex pre { width: 100%; overflow: auto;}
			
			p.infolinks { margin: 0.5em 0em 0em 0em; padding: 0px; }
			
			#qssettings { padding: 0.5em; position: absolute; top: 0.2em; right: 0.2em; border: 1px gray solid; background-color: white; display: none; }
			#qssettings p { font-weight: bold; cursor: pointer; }
			#qssettings ul { display: none; list-style-type: none; padding-left: 0; margin: 0; }
			#qssettings.active ul { display: block; }
			
			@media print {
				p.infolinks, #qssettings, #qs { display: none !important; }
				table { border-width: 0px; }
				tr { page-break-inside: avoid; }
				th input, th select { display: none; }
			}
	</style>
</head>
	
	<body>
		<div id="qs">
			<form action="">
			<p>Global QuickSearch: <input type="text" name="qsfield" id="qsfield" autocomplete="off" title="Allows plain text as well as RegExp searches (rowbased)" /><input type="button" onclick="clearQS()" value="clear" />&nbsp; Number of matching entries: <span id="stat">0</span></p>
			<div id="qssettings">
				<p onclick="toggleQSettingsDialog()">Search Settings</p>
				<ul></ul>
			</div>
			</form>
		</div>
		<table id="qstable" class="sortable" border="1">
		<thead>
			<tr>
				<th width="10%" class="input">BibTeX-Key</th>
				<th width="20%" class="input">Author / Editor / Organization</th>
				<th             class="input">Title</th>
				<th width="5%"  class="dropd">Year</th>
				<th width="25%" class="input">Journal / Proceedings / Book</th>
				<th width="5%"  class="dropd">BibTeX type</th>
				<th width="5%"  class="input">Keywords</th>
			</tr>
		</thead>
		<tbody>
<tr id="bernaille2006traffic" class="entry">
				<td style="text-align: center;">bernaille2006traffic</td>
				<td>
					
						Bernaille, L.; Akodkenou, I.; Soule, A. &amp; Salamatian, K.
					
					
					
				</td>
				<td>
					
					Traffic classification on the fly
					
					<p class="infolinks">
						[<a href="javascript:toggleInfo('bernaille2006traffic','abstract')">Abstract</a>] 
						[<a href="javascript:toggleInfo('bernaille2006traffic','review')">Review</a>] 
						[<a href="javascript:toggleInfo('bernaille2006traffic','bibtex')">BibTeX</a>] 
						[<a href="http://portal.acm.org/citation.cfm?id=1129582.1129589">URL</a>]
						
						[<a href="http://portal.acm.org/ft_gateway.cfm?id=1129589&type=pdf&coll=GUIDE&dl=GUIDE&CFID=82105953&CFTOKEN=66681632">PDF</a>]
					</p>
				</td>
				<td style="text-align: center;">2006</td>
				<td>
					ACM SIGCOMM Computer Communication Review  <br/>Vol. 36 (2)  , pp. 23-26  &nbsp;
				</td>
				<td>article</td>
				<td></td>
			</tr>
			<tr id="abs_bernaille2006traffic" class="abstract noshow">
				<td colspan="7"><b>Abstract</b>: The early detection of applications associated with TCP flows is an essential step for network security and traffic engineering. The classic way to identify flows, i.e. looking at port numbers, is not effective anymore. On the other hand, state-of-the-art techniques cannot determine the application before the end of the TCP flow. In this editorial, we propose a technique that relies on the observation of the first five packets of a TCP connection to identify the application. This result opens a range of new possibilities for online traffic classification.</td>
			</tr>
			<tr id="rev_bernaille2006traffic" class="review noshow">
				<td colspan="7"><b>Review</b>: 1 only use sizes of the first 5 data pkt (not control pkt)<p>2 use K-means ML to cluster</td>
			</tr>
			<tr id="bib_bernaille2006traffic" class="bibtex noshow">
				<td colspan="7"><b>BibTeX</b>:
					<pre>
@article{bernaille2006traffic,
  author = {Bernaille, L. and Akodkenou, I. and Soule, A. and Salamatian, K.},
  title = {Traffic classification on the fly},
  journal = {ACM SIGCOMM Computer Communication Review},
  publisher = {ACM New York, NY, USA},
  year = {2006},
  volume = {36},
  number = {2},
  pages = {23--26},
  url = {http://portal.acm.org/citation.cfm?id=1129582.1129589},
  doi = {http://doi.acm.org/10.1145/1129582.1129589}
}
					</pre>
				</td>
			</tr><tr id="Cheeseman1996" class="entry">
				<td style="text-align: center;">Cheeseman1996</td>
				<td>
					
						Cheeseman, P. &amp; Stutz, J.
					
					
					
				</td>
				<td>
					
					Bayesian classification (AutoClass): Theory and results
					
					<p class="infolinks">
						
						
						[<a href="javascript:toggleInfo('Cheeseman1996','bibtex')">BibTeX</a>] 
						
						
						[<a href="http://staff.science.uva.nl/~maarten/ml2/doc/sheets/regenboog.pdf">PDF</a>]
					</p>
				</td>
				<td style="text-align: center;">1996</td>
				<td>
					       &nbsp;
				</td>
				<td>article</td>
				<td></td>
			</tr>
			<tr id="bib_Cheeseman1996" class="bibtex noshow">
				<td colspan="7"><b>BibTeX</b>:
					<pre>
@article{Cheeseman1996,
  author = {Cheeseman, P. and Stutz, J.},
  title = {Bayesian classification (AutoClass): Theory and results},
  publisher = {American Association for Artificial Intelligence Menlo Park, CA, USA},
  year = {1996}
}
					</pre>
				</td>
			</tr><tr id="10.1109/SP.2009.14" class="entry">
				<td style="text-align: center;">10.1109/SP.2009.14</td>
				<td>
					
						Comparetti, P.M.; Wondracek, G.; Kruegel, C. &amp; Kirda, E.
					
					
					
				</td>
				<td>
					
					Prospex: Protocol Specification Extraction
					
					<p class="infolinks">
						[<a href="javascript:toggleInfo('10.1109/SP.2009.14','abstract')">Abstract</a>] 
						
						[<a href="javascript:toggleInfo('10.1109/SP.2009.14','bibtex')">BibTeX</a>] 
						[<a href="http://www.computer.org/portal/web/csdl/doi/10.1109/SP.2009.14">URL</a>]
						
						
					</p>
				</td>
				<td style="text-align: center;">2009</td>
				<td>
					Security and Privacy, IEEE Symposium on  <br/>Vol. 0   , pp. 110-125  &nbsp;
				</td>
				<td>article</td>
				<td></td>
			</tr>
			<tr id="abs_10.1109/SP.2009.14" class="abstract noshow">
				<td colspan="7"><b>Abstract</b>: Protocol reverse engineering is the process of extracting application-level specifications for network protocols. Such specifications are very useful in a number of security-related contexts, for example, to perform deep packet inspection and black-box fuzzing, or to quickly understand custom botnet command and control (C&amp;C) channels.Since manual reverse engineering is a time-consuming and tedious process, a number of systems have been proposed that aim to automate this task. These systems either analyze network traffic directly or monitor the execution of the application that receives the protocol messages. While previous systems show that precise message formats can be extracted automatically, they do not provide a protocol specification.The reason is that they do not reverse engineer the protocol state machine.In this paper, we focus on closing this gap by presenting a system that is capable of automatically inferring state machines. This greatly enhances the results of automatic protocol reverse engineering, while further reducing the need for human interaction. We extend previous work that focuses on behavior-based message format extraction,and introduce techniques for identifying and clustering different types of messages not only based on their structure, but also according to the impact of each message on server behavior.Moreover, we present an algorithm for extracting the state machine.We have applied our techniques to a number of real-world protocols, including the command and control protocol used by a malicious bot. Our results demonstrate that we are able to extract format specifications for different types of messages and meaningful protocol state machines. We use these protocol specifications to automatically generate input for a stateful fuzzer,allowing us to discover security vulnerabilities in real-world applications.</td>
			</tr>
			<tr id="bib_10.1109/SP.2009.14" class="bibtex noshow">
				<td colspan="7"><b>BibTeX</b>:
					<pre>
@article{10.1109/SP.2009.14,
  author = {Paolo Milani Comparetti and Gilbert Wondracek and Christopher Kruegel and Engin Kirda},
  title = {Prospex: Protocol Specification Extraction},
  journal = {Security and Privacy, IEEE Symposium on},
  publisher = {IEEE Computer Society},
  year = {2009},
  volume = {0},
  pages = {110-125},
  url = {http://www.computer.org/portal/web/csdl/doi/10.1109/SP.2009.14},
  doi = {http://doi.ieeecomputersociety.org/10.1109/SP.2009.14}
}
					</pre>
				</td>
			</tr><tr id="dempster1977maximum" class="entry">
				<td style="text-align: center;">dempster1977maximum</td>
				<td>
					
						Dempster, A.; Laird, N.; Rubin, D. &amp; others
					
					
					
				</td>
				<td>
					
					Maximum likelihood from incomplete data via the EM algorithm
					
					<p class="infolinks">
						[<a href="javascript:toggleInfo('dempster1977maximum','abstract')">Abstract</a>] 
						
						[<a href="javascript:toggleInfo('dempster1977maximum','bibtex')">BibTeX</a>] 
						[<a href="http://www.jstor.org/sici?sici=0035-9246(1977)39:1%3C1:MLFIDV%3E2.0.CO;2-Z&origin=MSN&cookieSet=1">URL</a>]
						
						[<a href="http://www.jstor.org/page/termsConfirm.jsp?redirectUri=/stable/pdfplus/2984875.pdf">PDF</a>]
					</p>
				</td>
				<td style="text-align: center;">1977</td>
				<td>
					Journal of the Royal Statistical Society. Series B (Methodological)  <br/>Vol. 39 (1)  , pp. 1-38  &nbsp;
				</td>
				<td>article</td>
				<td></td>
			</tr>
			<tr id="abs_dempster1977maximum" class="abstract noshow">
				<td colspan="7"><b>Abstract</b>: A broadly applicable algorithm for computing maximum likelihood estimates from incomplete data is presented at various levels of generality. Theory showing the monotone behaviour of the likelihood and convergence of the algorithm is derived. Many examples are sketched, including missing value situations, applications to grouped, censored or truncated data, finite mixture models, variance component estimation, hyperparameter estimation, iteratively reweighted least squares and factor analysis.</td>
			</tr>
			<tr id="bib_dempster1977maximum" class="bibtex noshow">
				<td colspan="7"><b>BibTeX</b>:
					<pre>
@article{dempster1977maximum,
  author = {Dempster, A.P. and Laird, N.M. and Rubin, D.B. and others},
  title = {Maximum likelihood from incomplete data via the EM algorithm},
  journal = {Journal of the Royal Statistical Society. Series B (Methodological)},
  publisher = {Royal Statistical Society},
  year = {1977},
  volume = {39},
  number = {1},
  pages = {1--38},
  url = {http://www.jstor.org/sici?sici=0035-9246(1977)39:1%3C1:MLFIDV%3E2.0.CO;2-Z&amp;origin=MSN&amp;cookieSet=1}
}
					</pre>
				</td>
			</tr><tr id="Dunigan2000" class="entry">
				<td style="text-align: center;">Dunigan2000</td>
				<td>
					
						Dunigan, T.; Ostrouchov, G. &amp; UT-Battelle, L.
					
					
					
				</td>
				<td>
					
					Flow Characterization for Intrusion Detection
					
					<p class="infolinks">
						
						
						[<a href="javascript:toggleInfo('Dunigan2000','bibtex')">BibTeX</a>] 
						
						
						[<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.74.8957&rep=rep1&type=pdf">PDF</a>]
					</p>
				</td>
				<td style="text-align: center;">2000</td>
				<td>
					ORNL/TM-2001/115, November       &nbsp;
				</td>
				<td>article</td>
				<td></td>
			</tr>
			<tr id="bib_Dunigan2000" class="bibtex noshow">
				<td colspan="7"><b>BibTeX</b>:
					<pre>
@article{Dunigan2000,
  author = {Dunigan, T. and Ostrouchov, G. and UT-Battelle, LLC},
  title = {Flow Characterization for Intrusion Detection},
  journal = {ORNL/TM-2001/115, November},
  publisher = {Citeseer},
  year = {2000}
}
					</pre>
				</td>
			</tr><tr id="Gringoli2009" class="entry">
				<td style="text-align: center;">Gringoli2009</td>
				<td>
					
						Gringoli, F.; Salgarelli, L.; Dusi, M.; Cascarano, N.; Risso, F. &amp; claffy, k. c.
					
					
					
				</td>
				<td>
					
					GT: picking up the truth from the ground for internet traffic
					
					<p class="infolinks">
						[<a href="javascript:toggleInfo('Gringoli2009','abstract')">Abstract</a>] 
						
						[<a href="javascript:toggleInfo('Gringoli2009','bibtex')">BibTeX</a>] 
						[<a href="http://portal.acm.org/citation.cfm?id=1629607.1629610#">URL</a>]
						
						[<a href="http://portal.acm.org/ft_gateway.cfm?id=1629610&type=pdf&coll=GUIDE&dl=GUIDE&CFID=91725102&CFTOKEN=82897622">PDF</a>]
					</p>
				</td>
				<td style="text-align: center;">2009</td>
				<td>
					ACM SIGCOMM Computer Communication Review  <br/>Vol. 39 (5)  , pp. 12-18  &nbsp;
				</td>
				<td>article</td>
				<td></td>
			</tr>
			<tr id="abs_Gringoli2009" class="abstract noshow">
				<td colspan="7"><b>Abstract</b>: Much of Internet traffic modeling, firewall, and intrusion detection research requires traces where some ground truth regarding application and protocol is associated with each packet or flow. This paper presents the design, development and experimental evaluation of gt, an open source software toolset for associating ground truth information with Internet traffic traces. By probing the monitored host's kernel to obtain information on active Internet sessions, gt gathers ground truth at the application level. Preliminary experimental results show that gt's effectiveness comes at little cost in terms of overhead on the hosting machines. Furthermore, when coupled with other packet inspection mechanisms, gt can derive ground truth not only in terms of applications (e.g., e-mail), but also in terms of protocols (e.g., SMTP vs. POP3).</td>
			</tr>
			<tr id="bib_Gringoli2009" class="bibtex noshow">
				<td colspan="7"><b>BibTeX</b>:
					<pre>
@article{Gringoli2009,
  author = {Gringoli, F. and Salgarelli, Luca and Dusi, M. and Cascarano, N. and Risso, F. and claffy, k. c.},
  title = {GT: picking up the truth from the ground for internet traffic},
  journal = {ACM SIGCOMM Computer Communication Review},
  publisher = {ACM},
  year = {2009},
  volume = {39},
  number = {5},
  pages = {12--18},
  url = {http://portal.acm.org/citation.cfm?id=1629607.1629610#},
  doi = {http://doi.acm.org/10.1145/1629607.1629610}
}
					</pre>
				</td>
			</tr><tr id="Karagiannis2004" class="entry">
				<td style="text-align: center;">Karagiannis2004</td>
				<td>
					
						Karagiannis, T.; Broido, A. &amp; Faloutsos, M.
					
					
					
						ACM New York, NY, USA
					
				</td>
				<td>
					
					Transport layer identification of P2P traffic
					
					<p class="infolinks">
						
						[<a href="javascript:toggleInfo('Karagiannis2004','review')">Review</a>] 
						[<a href="javascript:toggleInfo('Karagiannis2004','bibtex')">BibTeX</a>] 
						
						
						
					</p>
				</td>
				<td style="text-align: center;">2004</td>
				<td>
					    Proceedings of the 4th ACM SIGCOMM conference on Internet measurement , pp. 121-134  &nbsp;
				</td>
				<td>conference</td>
				<td></td>
			</tr>
			<tr id="rev_Karagiannis2004" class="review noshow">
				<td colspan="7"><b>Review</b>: <1> Based on connection patterns of P2P network;<p><2> First method for characterizing P2P traffic using only knowledge of network dynamics rather than payload;<p><3> Use coral reef suite to process the tarce file;<p><4> Accuracy: 95%, false positive: under 10%</td>
			</tr>
			<tr id="bib_Karagiannis2004" class="bibtex noshow">
				<td colspan="7"><b>BibTeX</b>:
					<pre>
@conference{Karagiannis2004,
  author = {Karagiannis, T. and Broido, A. and Faloutsos, M.},
  title = {Transport layer identification of P2P traffic},
  booktitle = {Proceedings of the 4th ACM SIGCOMM conference on Internet measurement},
  year = {2004},
  pages = {121--134}
}
					</pre>
				</td>
			</tr><tr id="Karagiannis2005" class="entry">
				<td style="text-align: center;">Karagiannis2005</td>
				<td>
					
						Karagiannis, T.; Papagiannaki, K. &amp; Faloutsos, M.
					
					
					
						ACM
					
				</td>
				<td>
					
					BLINC: multilevel traffic classification in the dark
					
					<p class="infolinks">
						[<a href="javascript:toggleInfo('Karagiannis2005','abstract')">Abstract</a>] 
						[<a href="javascript:toggleInfo('Karagiannis2005','review')">Review</a>] 
						[<a href="javascript:toggleInfo('Karagiannis2005','bibtex')">BibTeX</a>] 
						[<a href="http://portal.acm.org/citation.cfm?id=1080091.1080119">URL</a>]
						
						[<a href="http://portal.acm.org/ft_gateway.cfm?id=1080119&type=pdf&coll=GUIDE&dl=GUIDE&CFID=80261965&CFTOKEN=17920609">PDF</a>]
					</p>
				</td>
				<td style="text-align: center;">2005</td>
				<td>
					    Proceedings of the 2005 conference on Applications, technologies, architectures, and protocols for computer communications , pp. 240  &nbsp;
				</td>
				<td>conference</td>
				<td></td>
			</tr>
			<tr id="abs_Karagiannis2005" class="abstract noshow">
				<td colspan="7"><b>Abstract</b>: We present a fundamentally different approach to classifying traffic flows according to the applications that generate them. In contrast to previous methods, our approach is based on observing and identifying patterns of host behavior at the transport layer. We analyze these patterns at three levels of increasing detail (i) the social, (ii) the functional and (iii) the application level. This multilevel approach of looking at traffic flow is probably the most important contribution of this paper. Furthermore, our approach has two important features. First, it operates in the dark, having (a) no access to packet payload, (b) no knowledge of port numbers and (c) no additional information other than what current flow collectors provide. These restrictions respect privacy, technological and practical constraints. Second, it can be tuned to balance the accuracy of the classification versus the number of successfully classified traffic flows. We demonstrate the effectiveness of our approach on three real traces. Our results show that we are able to classify 80%-90% of the traffic with more than 95% accuracy.</td>
			</tr>
			<tr id="rev_Karagiannis2005" class="review noshow">
				<td colspan="7"><b>Review</b>: <1> only header informations;<p><2> classify at 3 levels: social level+functional level+application level</td>
			</tr>
			<tr id="bib_Karagiannis2005" class="bibtex noshow">
				<td colspan="7"><b>BibTeX</b>:
					<pre>
@conference{Karagiannis2005,
  author = {Karagiannis, T. and Papagiannaki, K. and Faloutsos, M.},
  title = {BLINC: multilevel traffic classification in the dark},
  booktitle = {Proceedings of the 2005 conference on Applications, technologies, architectures, and protocols for computer communications},
  year = {2005},
  pages = {240},
  url = {http://portal.acm.org/citation.cfm?id=1080091.1080119},
  doi = {http://doi.acm.org/10.1145/1080091.1080119}
}
					</pre>
				</td>
			</tr><tr id="McGregor2004" class="entry">
				<td style="text-align: center;">McGregor2004</td>
				<td>
					
						McGregor, A.; Hall, M.; Lorier, P. &amp; Brunskill, J.
					
					
					
				</td>
				<td>
					
					Flow clustering using machine learning techniques
					
					<p class="infolinks">
						[<a href="javascript:toggleInfo('McGregor2004','abstract')">Abstract</a>] 
						[<a href="javascript:toggleInfo('McGregor2004','review')">Review</a>] 
						[<a href="javascript:toggleInfo('McGregor2004','bibtex')">BibTeX</a>] 
						[<a href="http://www.springerlink.com/content/exh697awv2ctv8jr/">URL</a>]
						
						[<a href="http://www.springerlink.com/content/exh697awv2ctv8jr/fulltext.pdf">PDF</a>]
					</p>
				</td>
				<td style="text-align: center;">2004</td>
				<td>
					Lecture Notes in Computer Science  <br/>Vol. 3015   , pp. 205-214  &nbsp;
				</td>
				<td>article</td>
				<td></td>
			</tr>
			<tr id="abs_McGregor2004" class="abstract noshow">
				<td colspan="7"><b>Abstract</b>: Packet header traces are widely used in network analysis. Header traces are the aggregate of traffic from many concurrent applications. We present a methodology, based on machine learning, that can break the trace down into clusters of traffic where each cluster has different traffic characteristics. Typical clusters include bulk transfer, single and multiple transactions and interactive traffic, amongst others. The paper includes a description of the methodology, a visualisation of the attribute statistics that aids in recognising cluster types and a discussion of the stability and effectiveness of the methodology.</td>
			</tr>
			<tr id="rev_McGregor2004" class="review noshow">
				<td colspan="7"><b>Review</b>: use a fixed set of attributes, cluster flows into different application types.</td>
			</tr>
			<tr id="bib_McGregor2004" class="bibtex noshow">
				<td colspan="7"><b>BibTeX</b>:
					<pre>
@article{McGregor2004,
  author = {McGregor, A. and Hall, M. and Lorier, P. and Brunskill, J.},
  title = {Flow clustering using machine learning techniques},
  journal = {Lecture Notes in Computer Science},
  publisher = {Springer},
  year = {2004},
  volume = {3015},
  pages = {205--214},
  url = {http://www.springerlink.com/content/exh697awv2ctv8jr/},
  doi = {http://dx.doi.org/10.1007/b96961}
}
					</pre>
				</td>
			</tr><tr id="moore2005toward" class="entry">
				<td style="text-align: center;">moore2005toward</td>
				<td>
					
						Moore, A.W. &amp; Papagiannaki, K.
					
					
					
				</td>
				<td>
					
					Toward the accurate identification of network applications
					
					<p class="infolinks">
						[<a href="javascript:toggleInfo('moore2005toward','abstract')">Abstract</a>] 
						[<a href="javascript:toggleInfo('moore2005toward','review')">Review</a>] 
						[<a href="javascript:toggleInfo('moore2005toward','bibtex')">BibTeX</a>] 
						[<a href="http://www.springerlink.com/content/re7ej0uj7eep2htl/">URL</a>]
						
						[<a href="http://www.springerlink.com/content/re7ej0uj7eep2htl/fulltext.pdf">PDF</a>]
					</p>
				</td>
				<td style="text-align: center;">2005</td>
				<td>
					PAM, March       &nbsp;
				</td>
				<td>conference</td>
				<td></td>
			</tr>
			<tr id="abs_moore2005toward" class="abstract noshow">
				<td colspan="7"><b>Abstract</b>: Well-known port numbers can no longer be used to reliably identify network applications. There is a variety of new Internet applications that either do not use well-known port numbers or use other protocols, such as HTTP, as wrappers in order to go through firewalls without being blocked. One consequence of this is that a simple inspection of the port numbers used by flows may lead to the inaccurate classification of network traffic. In this work, we look at these inaccuracies in detail. Using a full payload packet trace collected from an Internet site we attempt to identify the types of errors that may result from port-based classification and quantify them for the specific trace under study. To address this question we devise a classification methodology that relies on the full packet payload. We describe the building blocks of this methodology and elaborate on the complications that arise in that context. A classification technique approaching 100% accuracy proves to be a labor-intensive process that needs to test flow-characteristics against multiple classification criteria in order to gain sufficient confidence in the nature of the causal application. Nevertheless, the benefits gained from a content-based classification approach are evident. We are capable of accurately classifying what would be otherwise classified as unknown as well as identifying traffic flows that could otherwise be classified incorrectly. Our work opens up multiple research issues that we intend to address in future work.</td>
			</tr>
			<tr id="rev_moore2005toward" class="review noshow">
				<td colspan="7"><b>Review</b>: combining different non-ML techniques to identify network applications</td>
			</tr>
			<tr id="bib_moore2005toward" class="bibtex noshow">
				<td colspan="7"><b>BibTeX</b>:
					<pre>
@conference{moore2005toward,
  author = {Andrew W. Moore and Konstantina Papagiannaki},
  title = {Toward the accurate identification of network applications},
  journal = {PAM, March},
  publisher = {Springer},
  year = {2005},
  url = {http://www.springerlink.com/content/re7ej0uj7eep2htl/}
}
					</pre>
				</td>
			</tr><tr id="moore2005internet" class="entry">
				<td style="text-align: center;">moore2005internet</td>
				<td>
					
						Moore, A.W. &amp; Zuev, D.
					
					
					
				</td>
				<td>
					
					Internet traffic classification using bayesian analysis techniques
					
					<p class="infolinks">
						[<a href="javascript:toggleInfo('moore2005internet','abstract')">Abstract</a>] 
						[<a href="javascript:toggleInfo('moore2005internet','review')">Review</a>] 
						[<a href="javascript:toggleInfo('moore2005internet','bibtex')">BibTeX</a>] 
						[<a href="http://portal.acm.org/citation.cfm?id=1071690.1064220">URL</a>]
						
						[<a href="http://portal.acm.org/ft_gateway.cfm?id=1064220&type=pdf&coll=GUIDE&dl=GUIDE&CFID=82103548&CFTOKEN=87148664">PDF</a>]
					</p>
				</td>
				<td style="text-align: center;">2005</td>
				<td>
					ACM SIGMETRICS Performance Evaluation Review  <br/>Vol. 33 (1) ACM SIGMETRICS Performance Evaluation Review , pp. 50-60  &nbsp;
				</td>
				<td>conference</td>
				<td></td>
			</tr>
			<tr id="abs_moore2005internet" class="abstract noshow">
				<td colspan="7"><b>Abstract</b>: Accurate traffic classification is of fundamental importance to numerous other network activities, from security monitoring to accounting, and from Quality of Service to providing operators with useful forecasts for long-term provisioning. We apply a Naïve Bayes estimator to categorize traffic by application. Uniquely, our work capitalizes on hand-classified network data, using it as input to a supervised Naïve Bayes estimator. In this paper we illustrate the high level of accuracy achievable with the Naive Bayes estimator. We further illustrate the improved accuracy of refined variants of this estimator.Our results indicate that with the simplest of Naïve Bayes estimator we are able to achieve about 65% accuracy on per-flow classification and with two powerful refinements we can improve this value to better than 95%; this is a vast improvement over traditional techniques that achieve 50--70%. While our technique uses training data, with categories derived from packet-content, all of our training and testing was done using header-derived discriminators. We emphasize this as a powerful aspect of our approach: using samples of well-known traffic to allow the categorization of traffic using commonly available information alone.</td>
			</tr>
			<tr id="rev_moore2005internet" class="review noshow">
				<td colspan="7"><b>Review</b>: <1> use Naive Bayes estimator to classify traffic which is hand-classified;<p><2> accuracy: 95%<p><3> only use header-derived discriminators</td>
			</tr>
			<tr id="bib_moore2005internet" class="bibtex noshow">
				<td colspan="7"><b>BibTeX</b>:
					<pre>
@conference{moore2005internet,
  author = {Andrew W. Moore and Denis Zuev},
  title = {Internet traffic classification using bayesian analysis techniques},
  booktitle = {ACM SIGMETRICS Performance Evaluation Review},
  journal = {ACM SIGMETRICS Performance Evaluation Review},
  publisher = {ACM New York, NY, USA},
  year = {2005},
  volume = {33},
  number = {1},
  pages = {50--60},
  url = {http://portal.acm.org/citation.cfm?id=1071690.1064220},
  doi = {http://doi.acm.org/10.1145/1071690.1064220}
}
					</pre>
				</td>
			</tr><tr id="Nguyen2008" class="entry">
				<td style="text-align: center;">Nguyen2008</td>
				<td>
					
						Nguyen, T. &amp; Armitage, G.
					
					
					
				</td>
				<td>
					
					A survey of techniques for internet traffic classification using machine learning
					
					<p class="infolinks">
						
						
						[<a href="javascript:toggleInfo('Nguyen2008','bibtex')">BibTeX</a>] 
						
						
						[<a href="http://www.caia.swin.edu.au/cv/garmitage/things/Nguyen_Armitage_SurveysAndTutorials2008.pdf">PDF</a>]
					</p>
				</td>
				<td style="text-align: center;">2008</td>
				<td>
					IEEE Communications Surveys and Tutorials  <br/>Vol. 10 (4)  , pp. 56-76  &nbsp;
				</td>
				<td>article</td>
				<td></td>
			</tr>
			<tr id="bib_Nguyen2008" class="bibtex noshow">
				<td colspan="7"><b>BibTeX</b>:
					<pre>
@article{Nguyen2008,
  author = {Nguyen, T.T.T. and Armitage, G.},
  title = {A survey of techniques for internet traffic classification using machine learning},
  journal = {IEEE Communications Surveys and Tutorials},
  year = {2008},
  volume = {10},
  number = {4},
  pages = {56--76}
}
					</pre>
				</td>
			</tr><tr id="roughan2004class-of-service" class="entry">
				<td style="text-align: center;">roughan2004class-of-service</td>
				<td>
					
						Roughan, M.; Sen, S.; Spatscheck, O. &amp; Duffield, N.
					
					
					
						ACM New York, NY, USA
					
				</td>
				<td>
					
					Class-of-service mapping for QoS: a statistical signature-based approach to IP traffic classification
					
					<p class="infolinks">
						[<a href="javascript:toggleInfo('roughan2004class-of-service','abstract')">Abstract</a>] 
						[<a href="javascript:toggleInfo('roughan2004class-of-service','review')">Review</a>] 
						[<a href="javascript:toggleInfo('roughan2004class-of-service','bibtex')">BibTeX</a>] 
						[<a href="http://portal.acm.org/citation.cfm?id=1028788.1028805">URL</a>]
						
						[<a href="http://portal.acm.org/ft_gateway.cfm?id=1028805&type=pdf&coll=GUIDE&dl=GUIDE&CFID=82099491&CFTOKEN=23121113">PDF</a>]
					</p>
				</td>
				<td style="text-align: center;">2004</td>
				<td>
					    Proceedings of the 4th ACM SIGCOMM conference on Internet measurement , pp. 135-148  &nbsp;
				</td>
				<td>conference</td>
				<td></td>
			</tr>
			<tr id="abs_roughan2004class-of-service" class="abstract noshow">
				<td colspan="7"><b>Abstract</b>: The ability to provide different Quality of Service (QoS) guarantees to traffic from different applications is a highly desired feature for many IP network operators, particularly for enterprise networks. Although various mechanisms exist for providing QoS in the network, QoS is yet to be widely deployed. We believe that a key factor holding back widespread QoS adoption is the absence of suitable methodologies/processes for appropriately mapping the traffic from different applications to different QoS classes. This is a challenging task, because many enterprise network operators who are interested in QoS do not know all the applications running on their network, and furthermore, over recent years port-based application classification has become problematic. We argue that measurement based automated Class of Service (CoS) mapping is an important practical problem that needs to be studied.<p>In this paper we describe the requirements and associated challenges, and outline a solution framework for measurement based classification of traffic for QoS based on statistical application signatures. In our approach the signatures are chosen in such as way as to make them insensitive to the particular application layer protocol, but rather to determine the way in which an application is used -- for instance is it used interactively, or for bulk-data transport. The resulting application signature can then be used to derive the network layer signatures required to determine the CoS class for individual IP datagrams. Our evaluations using traffic traces from a variety of network locations, demonstrate the feasibility and potential of the approach.</td>
			</tr>
			<tr id="rev_roughan2004class-of-service" class="review noshow">
				<td colspan="7"><b>Review</b>: <1> use NN (nearest neighbour) and LDA (linear discriminate analysis) to map applications to different Qos classes<p><2> use up to four attributes</td>
			</tr>
			<tr id="bib_roughan2004class-of-service" class="bibtex noshow">
				<td colspan="7"><b>BibTeX</b>:
					<pre>
@conference{roughan2004class-of-service,
  author = {Roughan, M. and Sen, S. and Spatscheck, O. and Duffield, N.},
  title = {Class-of-service mapping for QoS: a statistical signature-based approach to IP traffic classification},
  booktitle = {Proceedings of the 4th ACM SIGCOMM conference on Internet measurement},
  year = {2004},
  pages = {135--148},
  url = {http://portal.acm.org/citation.cfm?id=1028788.1028805},
  doi = {http://dx.doi.org/10.1145/1028788.1028805}
}
					</pre>
				</td>
			</tr><tr id="sen2004accurate" class="entry">
				<td style="text-align: center;">sen2004accurate</td>
				<td>
					
						Sen, S.; Spatscheck, O. &amp; Wang, D.
					
					
					
						ACM New York, NY, USA
					
				</td>
				<td>
					
					Accurate, scalable in-network identification of p2p traffic using application signatures
					
					<p class="infolinks">
						[<a href="javascript:toggleInfo('sen2004accurate','abstract')">Abstract</a>] 
						
						[<a href="javascript:toggleInfo('sen2004accurate','bibtex')">BibTeX</a>] 
						[<a href="http://portal.acm.org/citation.cfm?id=988742">URL</a>]
						
						[<a href="http://portal.acm.org/ft_gateway.cfm?id=988742&type=pdf&coll=GUIDE&dl=GUIDE&CFID=82105745&CFTOKEN=35093549">PDF</a>]
					</p>
				</td>
				<td style="text-align: center;">2004</td>
				<td>
					    Proceedings of the 13th international conference on World Wide Web , pp. 512-521  &nbsp;
				</td>
				<td>conference</td>
				<td></td>
			</tr>
			<tr id="abs_sen2004accurate" class="abstract noshow">
				<td colspan="7"><b>Abstract</b>: The ability to accurately identify the network traffic associated with different P2P applications is important to a broad range of network operations including application-specific traffic engineering, capacity planning, provisioning, service differentiation,etc. However, traditional traffic to higher-level application mapping techniques such as default server TCP or UDP network-port baseddisambiguation is highly inaccurate for some P2P applications.In this paper, we provide an efficient approach for identifying the P2P application traffic through application level signatures. We firstidentify the application level signatures by examining some available documentations, and packet-level traces. We then utilize the identified signatures to develop online filters that can efficiently and accurately track the P2P traffic even on high-speed network links.We examine the performance of our application-level identification approach using five popular P2P protocols. Our measurements show thatour technique achieves less than 5% false positive and false negative ratios in most cases. We also show that our approach only requires the examination of the very first few packets (less than 10packets) to identify a P2P connection, which makes our approach highly scalable. Our technique can significantly improve the P2P traffic volume estimates over what pure network port based approaches provide. For instance, we were able to identify 3 times as much traffic for the popular Kazaa P2P protocol, compared to the traditional port-based approach.</td>
			</tr>
			<tr id="bib_sen2004accurate" class="bibtex noshow">
				<td colspan="7"><b>BibTeX</b>:
					<pre>
@conference{sen2004accurate,
  author = {Sen, S. and Spatscheck, O. and Wang, D.},
  title = {Accurate, scalable in-network identification of p2p traffic using application signatures},
  booktitle = {Proceedings of the 13th international conference on World Wide Web},
  year = {2004},
  pages = {512--521},
  url = {http://portal.acm.org/citation.cfm?id=988742},
  doi = {http://doi.acm.org/10.1145/988672.988742}
}
					</pre>
				</td>
			</tr><tr id="Zander2005" class="entry">
				<td style="text-align: center;">Zander2005</td>
				<td>
					
						Zander, S.; Nguyen, T. &amp; Armitage, G.
					
					
					
						IEEE
					
				</td>
				<td>
					
					Automated traffic classification and application identification using machine learning
					
					<p class="infolinks">
						[<a href="javascript:toggleInfo('Zander2005','abstract')">Abstract</a>] 
						[<a href="javascript:toggleInfo('Zander2005','review')">Review</a>] 
						[<a href="javascript:toggleInfo('Zander2005','bibtex')">BibTeX</a>] 
						[<a href="http://portal.acm.org/citation.cfm?id=1104999.1105362">URL</a>]
						
						[<a href="http://caia.swin.edu.au/cv/szander/publications/01550864.pdf">PDF</a>]
					</p>
				</td>
				<td style="text-align: center;">2005</td>
				<td>
					  <br/>Vol. 30  Conference on Local Computer Networks , pp. 250  &nbsp;
				</td>
				<td>conference</td>
				<td></td>
			</tr>
			<tr id="abs_Zander2005" class="abstract noshow">
				<td colspan="7"><b>Abstract</b>: The dynamic classification and identification of network applications responsible for network traffic flows offers substantial benefits to a number of key areas in IP network engineering, management and surveillance. Currently such classifications rely on selected packet header fields (e.g. port numbers) or application layer protocol decoding. These methods have a number of shortfalls e.g. many applications can use unpredictable port numbers and protocol decoding requires a high amount of computing resources or is simply infeasible in case protocols are unknown or encrypted. We propose a novel method for traffic classification and application identification using an unsupervised machine learning technique. Flows are automatically classified based on statistical flow characteristics. We evaluate the efficiency of our approach using data from several traffic traces collected at different locations of the Internet. We use feature selection to find an optimal feature set and determine the influence of different features.</td>
			</tr>
			<tr id="rev_Zander2005" class="review noshow">
				<td colspan="7"><b>Review</b>: <1> evaluate the unsuperviesed-ML approach using a number of traffic traces collected at different locations in the internet;<p><2> use the Autoclass approach</td>
			</tr>
			<tr id="bib_Zander2005" class="bibtex noshow">
				<td colspan="7"><b>BibTeX</b>:
					<pre>
@conference{Zander2005,
  author = {Zander, S. and Nguyen, T. and Armitage, G.},
  title = {Automated traffic classification and application identification using machine learning},
  booktitle = {Conference on Local Computer Networks},
  year = {2005},
  volume = {30},
  pages = {250},
  url = {http://portal.acm.org/citation.cfm?id=1104999.1105362},
  doi = {http://dx.doi.org/10.1109/LCN.2005.35}
}
					</pre>
				</td>
			</tr><tr id="zander2005self" class="entry">
				<td style="text-align: center;">zander2005self</td>
				<td>
					
						Zander, S.; Nguyen, T. &amp; Armitage, G.
					
					
					
						Springer
					
				</td>
				<td>
					
					Self-learning IP traffic classification based on statistical flow characteristics
					
					<p class="infolinks">
						[<a href="javascript:toggleInfo('zander2005self','abstract')">Abstract</a>] 
						[<a href="javascript:toggleInfo('zander2005self','review')">Review</a>] 
						[<a href="javascript:toggleInfo('zander2005self','bibtex')">BibTeX</a>] 
						[<a href="http://www.springerlink.com/content/my2lgwuleryl9phr/">URL</a>]
						
						[<a href="http://www.springerlink.com/content/my2lgwuleryl9phr/fulltext.pdf">PDF</a>]
					</p>
				</td>
				<td style="text-align: center;">2005</td>
				<td>
					    Proc. of the 6th Passive and Active Network Measurement Workshop , pp. 83  &nbsp;
				</td>
				<td>conference</td>
				<td></td>
			</tr>
			<tr id="abs_zander2005self" class="abstract noshow">
				<td colspan="7"><b>Abstract</b>: A number of key areas in IP network engineering, management and surveillance greatly benefit from the ability to dynamically identify traffic flows according to the applications responsible for their creation. Currently such classifications rely on selected packet header fields (e.g. destination port) or application layer protocol decoding. These methods have a number of shortfalls e.g. many applications can use unpredictable port numbers and protocol decoding requires high resource usage or is simply infeasible in case protocols are unknown or encrypted. We propose a framework for application classification using an unsupervised machine learning (ML) technique. Flows are automatically classified based on their statistical characteristics. We also propose a systematic approach to identify an optimal set of flow attributes to use and evaluate the effectiveness of our approach using captured traffic traces.</td>
			</tr>
			<tr id="rev_zander2005self" class="review noshow">
				<td colspan="7"><b>Review</b>: use machine learning to identifying different applications</td>
			</tr>
			<tr id="bib_zander2005self" class="bibtex noshow">
				<td colspan="7"><b>BibTeX</b>:
					<pre>
@conference{zander2005self,
  author = {Zander, S. and Nguyen, T. and Armitage, G.},
  title = {Self-learning IP traffic classification based on statistical flow characteristics},
  booktitle = {Proc. of the 6th Passive and Active Network Measurement Workshop},
  year = {2005},
  pages = {83},
  url = {http://www.springerlink.com/content/my2lgwuleryl9phr/}
}
					</pre>
				</td>
			</tr><tr id="zuev2005traffic" class="entry">
				<td style="text-align: center;">zuev2005traffic</td>
				<td>
					
						Zuev, D. &amp; Moore, A.
					
					
					
						Springer
					
				</td>
				<td>
					
					Traffic classification using a statistical approach
					
					<p class="infolinks">
						[<a href="javascript:toggleInfo('zuev2005traffic','abstract')">Abstract</a>] 
						[<a href="javascript:toggleInfo('zuev2005traffic','review')">Review</a>] 
						[<a href="javascript:toggleInfo('zuev2005traffic','bibtex')">BibTeX</a>] 
						[<a href="http://www.springerlink.com/content/mwt155lc09k0v1le/">URL</a>]
						
						[<a href="http://www.springerlink.com/content/mwt155lc09k0v1le/fulltext.pdf">PDF</a>]
					</p>
				</td>
				<td style="text-align: center;">2005</td>
				<td>
					    Passive and Active Measurement   &nbsp;
				</td>
				<td>conference</td>
				<td></td>
			</tr>
			<tr id="abs_zuev2005traffic" class="abstract noshow">
				<td colspan="7"><b>Abstract</b>: Accurate traffic classification is the keystone of numerous network activities. Our work capitalises on hand-classified network data, used as input to a supervised Bayes estimator. We illustrate the high level of accuracy achieved with a supervised Naïve Bayes estimator; with the simplest estimator we are able to achieve better than 83% accuracy on both a per-byte and a per-packet basis.</td>
			</tr>
			<tr id="rev_zuev2005traffic" class="review noshow">
				<td colspan="7"><b>Review</b>: <1> use naive bayes classifier and a large number of flow attributes;<p><2> only use one data set which is hand-classified</td>
			</tr>
			<tr id="bib_zuev2005traffic" class="bibtex noshow">
				<td colspan="7"><b>BibTeX</b>:
					<pre>
@conference{zuev2005traffic,
  author = {Zuev, D. and Moore, A.},
  title = {Traffic classification using a statistical approach},
  booktitle = {Passive and Active Measurement},
  year = {2005},
  url = {http://www.springerlink.com/content/mwt155lc09k0v1le/}
}
					</pre>
				</td>
			</tr></tbody>
	</table>

	<p>
		<small>Created on 01/11/2010. <a href="http://security.riit.tsinghua.edu.cn/~bhyang/paper_read.html">Return</a></small>
	</p>

	</body>
</html>
