<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html lang="en">
	<head>
		<title>Paper List</title>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		
		<script type="text/javascript">
			<!--
				// QuickSearch script for JabRef HTML export 
				// Version: 3.0
				//
				// Copyright (c) 2006-2008, Mark Schenk
				// Copyright (c) 2009, Holger Jeromin <jeromin(at)plt.rwth-aachen.de>, Chair of Process Control Engineering, Aachen University of Technology
				//
				// This software is distributed under a Creative Commons Attribution 3.0 License
				// http://creativecommons.org/licenses/by/3.0/
				
				// Some features:
				// + optionally searches Abstracts and Reviews
				// + allows RegExp searches
				//   e.g. to search for entries between 1980 and 1989, type:  198[0-9]
				//   e.g. for any entry ending with 'symmetry', type:  symmetry$
				//   e.g. for all reftypes that are books: ^book$, or ^article$
				//   e.g. for entries by either John or Doe, type john|doe
				// + easy toggling of Abstract/Review/BibTeX
				
				// Features from Holger Jeromin
				// + incremental search in each column (input or dropdownbox)
				// + global search can search with multiple search words in the row
				//   global search of special regexp related to a cell is not possible anymore: ^2009$
				//   but this is possible in the local searches
				// + use of innerText/textContent for less function overhead
				
				// Search settings
				var searchAbstract = true;
				var searchReview = true;
				
				if (window.addEventListener) {
					window.addEventListener("load",initSearch,false); }
				else if (window.attachEvent) {
					window.attachEvent("onload", initSearch); }
				
				function initSearch() {

					// basic object detection
					if(!document.getElementById || !document.getElementsByTagName) { return; }
					if (!document.getElementById('qstable')||!document.getElementById('qs')) { return; }
				
					// find QS table and appropriate rows
					searchTable = document.getElementById('qstable');
					var allRows = searchTable.getElementsByTagName('tbody')[0].getElementsByTagName('tr');
				
					// split all rows into entryRows and infoRows (e.g. abstract, review, bibtex)
					entryRows = new Array();
					infoRows = new Array(); absRows = new Array(); revRows = new Array();
				
					for (var i=0, k=0, j=0; i<allRows.length;i++) {
						if (allRows[i].className.match(/entry/)) {
							entryRows[j++] = allRows[i];
						} else {
							infoRows[k++] = allRows[i];
							// check for abstract/review
							if (allRows[i].className.match(/abstract/)) {
								absRows.push(allRows[i]);
							} else if (allRows[i].className.match(/review/)) {
								revRows.push(allRows[i]);
							}
						}
					}
				
					//number of entries and rows
					numRows = allRows.length;
					numEntries = entryRows.length;
					numInfo = infoRows.length;
					numAbs = absRows.length;
					numRev = revRows.length;
				
					//find the query field
					qsfield = document.getElementById('qsfield');
				
					//find statistics location
					stats = document.getElementById('stat');
					setStatistics(-1);
				
					// creates the appropriate search settings
					createQSettingsDialog();
				
					// shows the searchfield
					document.getElementById('qs').style.display = 'block';
					qsfield.onkeyup = testEvent;
					qsfield.onchange = testEvent;
				}
				
				function quickSearch(tInput){
				
					var localSearchArray = new Array();
					var globalSearchText = null;
					var globalSearch = new Array();
					// only search for valid RegExp
					//this input is in the global field and the user has typed something in
					if (qsfield == tInput && tInput.value != ""){
						//clear all other search fields
						for(var i=0; i<tableheaders.length; i++) {
							if (tableheaders[i].lastChild.nodeName == "INPUT"){
								tableheaders[i].lastChild.value = "";
							}else if (tableheaders[i].lastChild.nodeName == "SELECT"){
								tableheaders[i].lastChild.selectedIndex = 0;
							}
							tableheaders[i].lastChild.className = '';
						}
						try {
							globalSearchText = qsfield.value.split(" ");
							for (var i = 0; i < globalSearchText.length; i++){
								if (globalSearchText[i]){
									globalSearch[i] = new RegExp(globalSearchText[i],"i");
								}
							}
						}catch(err) {
							tInput.className = 'invalidsearch';
							if (window.console != null){
								window.console.error("Search Error: %s", err);
							}
							return;
						}
					//this input is a local search => clear the global search
					}else if (tInput.value != ""){
						qsfield.value = "";
					}
					closeAllInfo();
					qsfield.className = '';
					for(var i=0; i<tableheaders.length; i++) {
						if (tableheaders[i].lastChild.value != ""){
							try {
								if(searchSubString[i] == true){
									localSearchArray[i] = new RegExp(tableheaders[i].lastChild.value,"i")
								}else{
									localSearchArray[i] = new RegExp("^"+tableheaders[i].lastChild.value+"$","i")
								}
							}catch(err) {
								tableheaders[i].lastChild.className = 'invalidsearch';
								if (window.console != null){
									window.console.error("Search Error: %s", err);
								}
								return;
							}
						}
						tableheaders[i].lastChild.className = '';
					}
					
					// count number of hits
					var hits = 0;
					//initialise variable
					var t;
					var inCells;
					var numCols;
					
					// start looping through all entry rows
					for (var i = 0; cRow = entryRows[i]; i++){
						var found = false; 
						
						if (globalSearch.length == 0 && localSearchArray.length == 0){ 
							//no search selected
							found=true;
						}else if (globalSearch.length != 0){
							t = undefined != cRow.innerText?cRow.innerText:cRow.textContent;
							for (var k = 0; k < globalSearch.length; k++){
								if (t.search(globalSearch[k]) == -1){ 
									found=false;
									break;
								}else{
									found=true;
								}
							}
						}else{
							inCells = cRow.getElementsByTagName('td');
							numCols = inCells.length;
							for (var j=0; j<numCols; j++) {
								if (undefined != localSearchArray[j]){
									cCell = inCells[j];
									t = undefined != cCell.innerText?cCell.innerText:cCell.textContent;
									if (t.search(localSearchArray[j]) == -1){
										found=false;
										break;
									}else{
										found=true;
									}
								}
							}
						}
						// look for further hits in Abstract and Review
						if(!found) {
							var articleid = cRow.id;
							if(searchAbstract && (abs = document.getElementById('abs_'+articleid))) {
								for (var k = 0; k < globalSearch.length; k++){
									if ((undefined != abs.innerText?abs.innerText:abs.textContent).search(globalSearch[k]) == -1){ 
										found=false;
										break;
									}else{
										found=true;
									}
								}
							}
							if(searchReview && (rev = document.getElementById('rev_'+articleid))) {
								for (var k = 0; k < globalSearch.length; k++){
									if ((undefined != rev.innerText?rev.innerText:rev.textContent).search(globalSearch[k]) == -1){ 
										found=false;
										break;
									}else{
										found=true;
									}
								}
							}
							articleid = null;
						}
						
						if(found) {
							cRow.className = 'entry show';
							hits++;
						} else {
							cRow.className = 'entry noshow';
						}
					}
					
					// update statistics
					setStatistics(hits)
				}
				
				function toggleInfo(articleid,info) {
					var entry = document.getElementById(articleid);
					var abs = document.getElementById('abs_'+articleid);
					var rev = document.getElementById('rev_'+articleid);
					var bib = document.getElementById('bib_'+articleid);
					
					// Get the abstracts/reviews/bibtext in the right location
					// in unsorted tables this is always the case, but in sorted tables it is necessary. 
					// Start moving in reverse order, so we get: entry, abstract,review,bibtex
					if (searchTable.className.indexOf('sortable') != -1) {
						if(bib) { entry.parentNode.insertBefore(bib,entry.nextSibling); }
						if(rev) { entry.parentNode.insertBefore(rev,entry.nextSibling); }
						if(abs) { entry.parentNode.insertBefore(abs,entry.nextSibling); }
					}
				
					if (abs && info == 'abstract') {
						if(abs.className.indexOf('abstract') != -1) {
						abs.className.indexOf('noshow') == -1?abs.className = 'abstract noshow':abs.className = 'abstract';
						}
					} else if (rev && info == 'review') {
						if(rev.className.indexOf('review') != -1) {
						rev.className.indexOf('noshow') == -1?rev.className = 'review noshow':rev.className = 'review';
						}
					} else if (bib && info == 'bibtex') {
						if(bib.className.indexOf('bibtex') != -1) {
						bib.className.indexOf('noshow') == -1?bib.className = 'bibtex noshow':bib.className = 'bibtex';
						}		
					} else { 
						return;
					}
				
					// check if one or the other is available
					var revshow = false;
					var absshow = false;
					var bibshow = false;
					(abs && abs.className.indexOf('noshow') == -1)? absshow = true: absshow = false;
					(rev && rev.className.indexOf('noshow') == -1)? revshow = true: revshow = false;	
					(bib && bib.className == 'bibtex')? bibshow = true: bibshow = false;
					
					// highlight original entry
					if(entry) {
						if (revshow || absshow || bibshow) {
						entry.className = 'entry highlight show';
						} else {
						entry.className = 'entry show';
						}		
					}
					
					// When there's a combination of abstract/review/bibtex showing, need to add class for correct styling
					if(absshow) {
						(revshow||bibshow)?abs.className = 'abstract nextshow':abs.className = 'abstract';
					} 
					if (revshow) {
						bibshow?rev.className = 'review nextshow': rev.className = 'review';
					}
					
				}
				
				function setStatistics (hits) {
					if(hits < 0) { hits=numEntries; }
					if(stats) { stats.firstChild.data = hits + '/' + numEntries}
				}
				
			
				function showAll(){
					// first close all abstracts, reviews, etc.
					closeAllInfo();
				
					for (var i = 0; i < numEntries; i++){
						entryRows[i].className = 'entry show'; 
					}
				}
				
				function closeAllInfo(){
					for (var i=0; i < numInfo; i++){
						if (infoRows[i].className.indexOf('noshow') ==-1) {
							infoRows[i].className = infoRows[i].className + ' noshow';
						}
					}
				}
				
				function testEvent(e){
					if (!e) var e = window.event;
					quickSearch(this);
				}
				
				function clearQS() {
					qsfield.value = '';
					for(var i=0; i<tableheaders.length; i++) {
						if (tableheaders[i].lastChild.nodeName == "INPUT"){
							tableheaders[i].lastChild.value = "";
						}else if (tableheaders[i].lastChild.nodeName == "SELECT"){
							tableheaders[i].lastChild.selectedIndex = 0;
						}
						//get rid of error color
						tableheaders[i].lastChild.className = '';
					}
					quickSearch(qsfield);
				}
				
				function redoQS(){
					showAll();
					quickSearch(qsfield);
				}
				
				// Create Search Settings
				function toggleQSettingsDialog() {
				
					var qssettings = document.getElementById('qssettings');
					
					if(qssettings.className.indexOf('active')==-1) {
						qssettings.className = 'active';
				
						if(absCheckBox && searchAbstract == true) { absCheckBox.checked = 'checked'; }
						if(revCheckBox && searchReview == true) { revCheckBox.checked = 'checked'; }
				
					} else {
						qssettings.className= '';
					}
				}
				
				function createQSettingsDialog(){
					var qssettingslist = document.getElementById('qssettings').getElementsByTagName('ul')[0];
					
					if(numAbs!=0) {
						var x = document.createElement('input');
						x.id = "searchAbs";
						x.type = "checkbox";
						x.onclick = toggleQSetting;
						var y = qssettingslist.appendChild(document.createElement('li')).appendChild(document.createElement('label'));
						y.appendChild(x);
						y.appendChild(document.createTextNode('search abstracts'));		
					}
					if(numRev!=0) {
						var x = document.createElement('input');
						x.id = "searchRev";
						x.type = "checkbox";		
						x.onclick = toggleQSetting;
						var y = qssettingslist.appendChild(document.createElement('li')).appendChild(document.createElement('label'));		
						y.appendChild(x);		
						y.appendChild(document.createTextNode('search reviews'));
					}
						
					// global variables
					absCheckBox = document.getElementById('searchAbs');
					revCheckBox = document.getElementById('searchRev');
					
					// show search settings
					if(absCheckBox||revCheckBox) {
						document.getElementById('qssettings').style.display = 'block';
					}
				}
				
				function toggleQSetting() {
					if(this.id=='searchAbs') { searchAbstract = !searchAbstract; }
					if(this.id=='searchRev') { searchReview = !searchReview; }
					redoQS()
				}
			-->
		</script>
		<script type="text/javascript">
		<!--
		// Automagically create a dropdown box for column heades marked with the 'dropd' class
		// Mostly useful for year / BibTeX-type fields
		
		if (window.addEventListener) {
			window.addEventListener("load",populateSelect,false) }
		else if (window.attachEvent) {
			window.attachEvent("onload",populateSelect); }
		
		function populateSelect() {
			// find the column with the dropdowns
			var searchTable = document.getElementById('qstable');
			tableheaders = searchTable.getElementsByTagName('thead')[0].getElementsByTagName('th');
			var allRows = searchTable.getElementsByTagName('tbody')[0].getElementsByTagName('tr');
			//initialise variables
			var interactionelement;
			var brelement;
			var selectlist;
			var colsinrow;
			var entryContent;
			var usedentries;
			searchSubString = new Array(tableheaders.length);
		
			for(var i=0; i<tableheaders.length; i++) {
				if(tableheaders[i].className=="input") {
					interactionelement = document.createElement('input');
					interactionelement.type = "text";
					interactionelement.size = 10;
					interactionelement.autocomplete = "off";
					interactionelement.onkeyup = testEvent;
					interactionelement.onchange = testEvent;
					searchSubString[i] = true;
				}else if(tableheaders[i].className=="dropd") {
					selectlist = new Array();
					for(var k=0; k<allRows.length; k++) {
						colsinrow = allRows[k].getElementsByTagName('td');
						if(colsinrow.length >= i) {
							entryContent = undefined != colsinrow[i].innerText?colsinrow[i].innerText:colsinrow[i].textContent;
							//avoid empty entrys
							if ("" != entryContent && undefined != entryContent){
								selectlist.push(entryContent);
							}
						}
					}
					// sort the entry array
					selectlist.sort();
					
					//clear duplicate entrys
					usedentries = new Array();
					usedentries.push(selectlist[0]);
					for(j=1; j<selectlist.length;j++) {
						if(selectlist[j]!= selectlist[j-1]) {
							usedentries.push(selectlist[j]);
						}
					}
					//create select Element
					interactionelement = document.createElement('select');
					//create descriptive first Element
					interactionelement.appendChild(document.createElement('option'));
					interactionelement.lastChild.appendChild(document.createTextNode('- all -'));
					interactionelement.lastChild.value = "";
					//create all Elements
					for(k=0; k<usedentries.length; k++) {
						interactionelement.appendChild(document.createElement('option'));
						interactionelement.lastChild.value = usedentries[k];
						interactionelement.lastChild.appendChild(document.createTextNode(usedentries[k]));
					}
					interactionelement.onchange = testEvent;
					searchSubString[i] = false;
				}
				//prevent clicking in the element start sorting the table
				interactionelement.onclick = cancelBubble;
				brelement = document.createElement('br');
				tableheaders[i].appendChild(brelement);
				tableheaders[i].appendChild(interactionelement);
			}
		}
		
		function cancelBubble(e){
			if (!e) var e = window.event;
			e.cancelBubble = true;
			if (e.stopPropagation) e.stopPropagation();	
		}
		function resetFilter(){
			var typeselect = document.getElementById('reftypeselect');
			typeselect.selectedIndex = 0;
		}
		
		-->
		</script>
<script type="text/javascript">
<!--
// Sort Table Script
// Version: 1.1
//
// Copyright (c) 2006-2008, Mark Schenk
// Copyright (c) 2009, Holger Jeromin <jeromin(at)plt.rwth-aachen.de>, Chair of Process Control Engineering, Aachen University of Technology

// Features from Holger Jeromin
// + use of innerText/textContent for less function overhead
// + search optimisation (only search in cell.firstchild) deactivated, firefox is fast enough with the use of textContent

// This software is distributed under a Creative Commons Attribution 3.0 License
// http://creativecommons.org/licenses/by/3.0/

// Sorting of columns with a lot of text can be slow, so some speed optimizations can be enabled,
// using the following variable
var SORT_SPEED_OPT = false;
// the optimization has one limitation on the functionality: when sorting search
// results, the expanded info, e.g. bibtex/review, is collapsed. In the non-optimized
// version they remain visible.

if (window.addEventListener) {
	window.addEventListener("load",initSortTable,false) }
else if (window.attachEvent) {
	window.attachEvent("onload", initSortTable); }

function initSortTable() {
	var alltables = document.getElementsByTagName('table');
	for(i=0;i<alltables.length;i++) {
		var currentTable = alltables[i];
		if(currentTable.className.indexOf('sortable') !=-1) {
			var thead = currentTable.getElementsByTagName('thead')[0];
			thead.title = 'Click on any column header to sort';
			for (var i=0;cell = thead.getElementsByTagName('th')[i];i++) {
				cell.onclick = function () { resortTable(this); };
				// make it possible to have a default sort column
				if(cell.className.indexOf('sort')!=-1) {
					resortTable(cell)
				}
			}
		}
	}
}

var SORT_COLUMN_INDEX;

function resortTable(td) {
	var column = td.cellIndex;
	var table = getParent(td,'TABLE');

	var allRows = table.getElementsByTagName('tbody')[0].getElementsByTagName('tr');
	var newRows = new Array();

	for (var i=0, k=0; i<allRows.length;i++) {

		var rowclass = allRows[i].className;

		if (rowclass.indexOf('entry') != -1) {
			newRows[k++] = allRows[i];
		}
		
		if (SORT_SPEED_OPT) {
			// remove highlight class
			allRows[i].className = rowclass.replace(/highlight/,'');
			// close information
			if(rowclass.indexOf('entry') == -1 && rowclass.indexOf('noshow') == -1) { allRows[i].className = rowclass + ' noshow';}
		}
	}

	// If other sort functions are deemed necessary (e.g. for
	// dates and currencies) they can be added.
	var sortfn = ts_sort_caseinsensitive;
	SORT_COLUMN_INDEX = column;
	newRows.sort(sortfn);

	// create a container for showing sort arrow
	var arrow =  td.getElementsByTagName('span')[0];
	if (!arrow) { var arrow = td.insertBefore(document.createElement('span'), td.childNodes[1]);}
	
	if (td.className) {
		if (td.className.indexOf('sort_asc') !=-1) {
			td.className = td.className.replace(/_asc/,"_des");
			newRows.reverse();
			arrow.innerHTML = ' &uarr;';
		} else if (td.className.indexOf('sort_des') !=-1) {
			td.className = td.className.replace(/_des/,"_asc");
			arrow.innerHTML = ' &darr;';
		} else { 
			td.className += ' sort_asc'; 
			arrow.innerHTML = ' &darr;';
		}
	} else {
		td.className += 'sort_asc';
		arrow.innerHTML = ' &darr;';
	}
	
	// Remove the classnames and up/down arrows for the other headers
	var ths = table.getElementsByTagName('thead')[0].getElementsByTagName('th');
	for (var i=0; i<ths.length; i++) {
		if(ths[i]!=td && ths[i].className.indexOf('sort_')!=-1) {
		// argh, moronic JabRef thinks (backslash)w is an output field!!
		//ths[i].className = ths[i].className.replace(/sort_(backslash)w{3}/,"");
		ths[i].className = ths[i].className.replace(/sort_asc/,"");
		ths[i].className = ths[i].className.replace(/sort_des/,"");

		// remove span
		var arrow =  ths[i].getElementsByTagName('span')[0];
		if (arrow) { ths[i].removeChild(arrow); }
		}
	}

	// We appendChild rows that already exist to the tbody, so it moves them rather than creating new ones
	for (i=0;i<newRows.length;i++) { 
		table.getElementsByTagName('tbody')[0].appendChild(newRows[i]);

		if(!SORT_SPEED_OPT){
		// moving additional information, e.g. bibtex/abstract to right locations
		// this allows to sort, even with abstract/review/etc. still open
		var articleid = newRows[i].id;

		var entry = document.getElementById(articleid);
		var abs = document.getElementById('abs_'+articleid);
		var rev = document.getElementById('rev_'+articleid);
		var bib = document.getElementById('bib_'+articleid);		
	
		var tbody = table.getElementsByTagName('tbody')[0];
		// mind the order of adding the entries
		if(abs) { tbody.appendChild(abs); }
		if(rev) { tbody.appendChild(rev); }
		if(bib) { tbody.appendChild(bib); }
		}
	}
}


function ts_sort_caseinsensitive(a,b) {
	aa = (undefined != a.cells[SORT_COLUMN_INDEX].innerText?a.cells[SORT_COLUMN_INDEX].innerText:a.cells[SORT_COLUMN_INDEX].textContent).toLowerCase();
	bb = (undefined != b.cells[SORT_COLUMN_INDEX].innerText?b.cells[SORT_COLUMN_INDEX].innerText:b.cells[SORT_COLUMN_INDEX].textContent).toLowerCase();
	if (aa==bb) return 0;
	if (aa<bb) return -1;
	return 1;
}

function ts_sort_default(a,b) {
	aa = (undefined != a.cells[SORT_COLUMN_INDEX].innerText?a.cells[SORT_COLUMN_INDEX].innerText:a.cells[SORT_COLUMN_INDEX].textContent);
	bb = (undefined != b.cells[SORT_COLUMN_INDEX].innerText?b.cells[SORT_COLUMN_INDEX].innerText:b.cells[SORT_COLUMN_INDEX].textContent);
	if (aa==bb) return 0;
	if (aa<bb) return -1;
	return 1;
}

function getParent(el, pTagName) {
	if (el == null) { 
		return null;
	} else if (el.nodeType == 1 && el.tagName.toLowerCase() == pTagName.toLowerCase()) {
		return el;
	} else {
		return getParent(el.parentNode, pTagName);
	}
}
-->
</script>
		<style type="text/css">
			body { background-color: white; font-family: "Trebuchet MS", Arial, sans-serif; font-size: 12px; line-height: 1.2; padding: 1em; color: #2E2E2E; }
			
			#qs { width: auto; border-style: solid; border-color: gray; border-width: 1px 1px 0px 1px; padding: 0.5em 0.5em; display:none; position:relative; }
			#qs form { padding: 0px; margin: 0px; }
			#qs form p { padding: 0px; margin: 0px; }
			
			.invalidsearch { background-color: red; }
			
			table { border: 1px gray solid; width: 100%; empty-cells: show; }
			th, td { border: 1px gray solid; padding: 0.5em; vertical-align: top;  }
			td { text-align: left; vertical-align: top; }
			th { background-color: #EFEFEF; }
			
			td a { color: navy; text-decoration: none; }
			td a:hover  { text-decoration: underline; }
			
			tr.noshow { display: none;}
			
			tr.highlight td { background-color: #F1F1F1; border-top: 2px black solid; font-weight: bold; }
			tr.abstract td, tr.review td, tr.bibtex td { background-color: #F1F1F1; border-bottom: 2px black solid; }
			tr.nextshow td { border-bottom: 1px gray solid; }
			
			tr.bibtex pre { width: 100%; overflow: auto;}
			
			p.infolinks { margin: 0.5em 0em 0em 0em; padding: 0px; }
			
			#qssettings { padding: 0.5em; position: absolute; top: 0.2em; right: 0.2em; border: 1px gray solid; background-color: white; display: none; }
			#qssettings p { font-weight: bold; cursor: pointer; }
			#qssettings ul { display: none; list-style-type: none; padding-left: 0; margin: 0; }
			#qssettings.active ul { display: block; }
			
			@media print {
				p.infolinks, #qssettings, #qs { display: none !important; }
				table { border-width: 0px; }
				tr { page-break-inside: avoid; }
				th input, th select { display: none; }
			}
	</style>
</head>
	
	<body>
		<div id="qs">
			<form action="">
			<p>Global QuickSearch: <input type="text" name="qsfield" id="qsfield" autocomplete="off" title="Allows plain text as well as RegExp searches (rowbased)" /><input type="button" onclick="clearQS()" value="clear" />&nbsp; Number of matching entries: <span id="stat">0</span></p>
			<div id="qssettings">
				<p onclick="toggleQSettingsDialog()">Search Settings</p>
				<ul></ul>
			</div>
			</form>
		</div>
		<table id="qstable" class="sortable" border="1">
		<thead>
			<tr>
				<th width="10%" class="input">BibTeX-Key</th>
				<th width="20%" class="input">Author / Editor / Organization</th>
				<th             class="input">Title</th>
				<th width="5%"  class="dropd">Year</th>
				<th width="25%" class="input">Journal / Proceedings / Book</th>
				<th width="5%"  class="dropd">BibTeX type</th>
				<th width="5%"  class="input">Keywords</th>
			</tr>
		</thead>
		<tbody>
<tr id="baboescu2003packet" class="entry">
				<td style="text-align: center;">baboescu2003packet</td>
				<td>
					
						Baboescu, F.; Singh, S. &amp; Varghese, G.
					
					
					
				</td>
				<td>
					
					Packet classification for core routers: is there an alternative to CAMs?
					
					<p class="infolinks">
						[<a href="javascript:toggleInfo('baboescu2003packet','abstract')">Abstract</a>] 
						
						[<a href="javascript:toggleInfo('baboescu2003packet','bibtex')">BibTeX</a>] 
						[<a href="http://ieeexplore.ieee.org/search/srchabstract.jsp?tp=&arnumber=1208658&queryText%3DPacket+classification+for+core+routers:+Is+there+an+alternative+to+CAMs%3F%26openedRefinements%3D*%26searchField%3DSearch+All">URL</a>]
						
						[<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=1208658">PDF</a>]
					</p>
				</td>
				<td style="text-align: center;">2003</td>
				<td>
					INFOCOM 2003. Twenty-Second Annual Joint Conference of the IEEE Computer and Communications. IEEE Societies  <br/>Vol. 1   , pp.  53 - 63 vol.1  &nbsp;
				</td>
				<td>inproceedings</td>
				<td> abv; cam; hicuts; oc-768 speed; rfc; sram; board area; classification algorithm; core router; extended grid-of-tries with path compression algorithm; hardware solution; header field; packet classification; synthetic database; tier 1 isp; internet; decision trees; packet switching; telecommunication network routing; very large databases;</td>
			</tr>
			<tr id="abs_baboescu2003packet" class="abstract noshow">
				<td colspan="7"><b>Abstract</b>: A classifier consists of a set of rules for classifying packets based on header fields. Because core routers can have fairly large (e.g., 2000 rule) database and must use limited SRAM to meet OC-768 speeds, the best existing classification algorithms (RFC, HiCuts, ABV) are precluded because of the large amount of memory they need. Thus the general belief is that hardware solutions like CAMs are needed, despite the amount of board area and power they consume. In this paper, we provide an alternative to CAMs via an extended grid-of-tries with path compression (EGT-PC) algorithm whose worst-case speed scales well with database size while using a minimal amount of memory. Our evaluation is based on real databases used by tier 1 ISPs, and synthetic databases. EGT-PC is based on a observation that we found holds for all the tier 1 databases we studied: regardless of database size, any packet matches only a small number of distinct source-destination prefix pairs. The code we wrote for EGT-PC, RFC, HiCuts, and ABV is publicly available (Ref.1), providing the first publicly available code to encourage experimentation with classification algorithms.</td>
			</tr>
			<tr id="bib_baboescu2003packet" class="bibtex noshow">
				<td colspan="7"><b>BibTeX</b>:
					<pre>
@inproceedings{baboescu2003packet,
  author = {Baboescu, F. and Sumeet Singh and Varghese, G.},
  title = {Packet classification for core routers: is there an alternative to CAMs?},
  journal = {INFOCOM 2003. Twenty-Second Annual Joint Conference of the IEEE Computer and Communications. IEEE Societies},
  year = {2003},
  volume = {1},
  pages = { 53 - 63 vol.1},
  url = {http://ieeexplore.ieee.org/search/srchabstract.jsp?tp=&amp;arnumber=1208658&amp;queryText%3DPacket+classification+for+core+routers:+Is+there+an+alternative+to+CAMs%3F%26openedRefinements%3D*%26searchField%3DSearch+All}
}
					</pre>
				</td>
			</tr><tr id="baboescu2005scalable" class="entry">
				<td style="text-align: center;">baboescu2005scalable</td>
				<td>
					
						Baboescu, F. &amp; Varghese, G.
					
					
					
				</td>
				<td>
					
					Scalable packet classification
					
					<p class="infolinks">
						[<a href="javascript:toggleInfo('baboescu2005scalable','abstract')">Abstract</a>] 
						
						[<a href="javascript:toggleInfo('baboescu2005scalable','bibtex')">BibTeX</a>] 
						[<a href="http://portal.acm.org/citation.cfm?id=1056408.1056410#">URL</a>]
						
						[<a href="http://portal.acm.org/ft_gateway.cfm?id=1056410&type=pdf&coll=GUIDE&dl=GUIDE&CFID=81258338&CFTOKEN=72597747">PDF</a>]
					</p>
				</td>
				<td style="text-align: center;">2005</td>
				<td>
					IEEE/ACM Transactions on Networking (TON)  <br/>Vol. 13 (1)  , pp. 2-14  &nbsp;
				</td>
				<td>inproceedings</td>
				<td></td>
			</tr>
			<tr id="abs_baboescu2005scalable" class="abstract noshow">
				<td colspan="7"><b>Abstract</b>: Packet classification is important for applications such as firewalls, intrusion detection, and differentiated services. Existing algorithms for packet classification reported in the literature scale poorly in either time or space as filter databases grow in size. Hardware solutions such as TCAMs do not scale to large classifiers. However, even for large classifiers (say, 100 000 rules), any packet is likely to match a few (say, 10) rules. This paper seeks to exploit this observation to produce a scalable packet classification scheme called Aggregated Bit Vector (ABV). It takes the bit vector search algorithm (BV) described in Lakshman and Stidialis, 1998 (which takes linear time) and adds two new ideas, recursive aggregation of bit maps and filter rearrangement, to create ABV (which can take logarithmic time for many databases). We show that ABV outperforms BV by an order of magnitude using simulations on both industrial firewall databases and synthetically generated databases.</td>
			</tr>
			<tr id="bib_baboescu2005scalable" class="bibtex noshow">
				<td colspan="7"><b>BibTeX</b>:
					<pre>
@inproceedings{baboescu2005scalable,
  author = {Baboescu, Florin and Varghese, George},
  title = {Scalable packet classification},
  journal = {IEEE/ACM Transactions on Networking (TON)},
  publisher = {IEEE Press},
  year = {2005},
  volume = {13},
  number = {1},
  pages = {2--14},
  url = {http://portal.acm.org/citation.cfm?id=1056408.1056410#},
  doi = {http://dx.doi.org/10.1109/TNET.2004.842232}
}
					</pre>
				</td>
			</tr><tr id="feldmann2000tradeoffs" class="entry">
				<td style="text-align: center;">feldmann2000tradeoffs</td>
				<td>
					
						Feldmann, A. &amp; Muthukrishnan, S.
					
					
					
				</td>
				<td>
					
					Tradeoffs for Packet Classification
					
					<p class="infolinks">
						[<a href="javascript:toggleInfo('feldmann2000tradeoffs','abstract')">Abstract</a>] 
						
						[<a href="javascript:toggleInfo('feldmann2000tradeoffs','bibtex')">BibTeX</a>] 
						[<a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.29.4777">URL</a>]
						
						[<a href="www.net.t-labs.tu-berlin.de/papers/FM-TPC-00.pdf">PDF</a>]
					</p>
				</td>
				<td style="text-align: center;">2000</td>
				<td>
					       &nbsp;
				</td>
				<td>inproceedings</td>
				<td></td>
			</tr>
			<tr id="abs_feldmann2000tradeoffs" class="abstract noshow">
				<td colspan="7"><b>Abstract</b>: We present an algorithmic framework for solving the packet classification problem that allows various access time vs. memory tradeoffs. It reduces the multi-dimensional packet classification problem to solving a few instances of the one-dimensional IP lookup problem. It gives the best known lookup performance with moderately large memory space. Furthermore, it efficiently supports a reasonable number of additions and deletions to the rulesets without degrading the lookup performance. We perform a thorough experimental study of the tradeoffs for the two-dimensional packet classification problem on rulesets derived from datasets collected from AT&amp;T WorldNet, an Internet Service Provider.</td>
			</tr>
			<tr id="bib_feldmann2000tradeoffs" class="bibtex noshow">
				<td colspan="7"><b>BibTeX</b>:
					<pre>
@inproceedings{feldmann2000tradeoffs,
  author = {Anja Feldmann and S. Muthukrishnan},
  title = {Tradeoffs for Packet Classification},
  year = {2000},
  url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.29.4777},
  doi = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.29.4777}
}
					</pre>
				</td>
			</tr><tr id="gupta1999hicuts" class="entry">
				<td style="text-align: center;">gupta1999hicuts</td>
				<td>
					
						Gupta, P.; Gupta, P. &amp; Mckeown, N.
					
					
					
				</td>
				<td>
					
					Packet Classification using Hierarchical Intelligent Cuttings
					
					<p class="infolinks">
						[<a href="javascript:toggleInfo('gupta1999hicuts','abstract')">Abstract</a>] 
						
						[<a href="javascript:toggleInfo('gupta1999hicuts','bibtex')">BibTeX</a>] 
						[<a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.6.7809">URL</a>]
						
						[<a href="">PDF</a>]
					</p>
				</td>
				<td style="text-align: center;">1999</td>
				<td>
					    in Hot Interconnects VII , pp. 34-41  &nbsp;
				</td>
				<td>inproceedings</td>
				<td></td>
			</tr>
			<tr id="abs_gupta1999hicuts" class="abstract noshow">
				<td colspan="7"><b>Abstract</b>: Internet routers that operate as firewalls, or provide a variety of service classes, perform different operations on different flows. A flow is defined to be all the packets sharing common header characteristics; for example a flow may be defined as all the packets between two specific IP addresses. In order to classify a packet, a router consults a table (or classifier) using one or more fields from the packet header to search for the corresponding flow. The classifier is a list of rules that identify each flow and the actions to be performed on each. With the increasing demands on router performance, there is a need for algorithms that can classify packets quickly with minimal storage requirements and allow new flows to be frequently added and deleted. In the worst case, packet classification is hard requiring routers to use heuristics that exploit structure present in the classifiers. This paper presents such a heuristic, called HiCuts, (hierarchical intelligent cuttings), which exploits the structure found in classifiers. We describe HiCuts and examine its performance against real classifiers in use today. When compared with previously described algorithms and used to classify packets based on four header fields, the algorithm is found to classify packets quickly and has relatively small storage requirements.</td>
			</tr>
			<tr id="bib_gupta1999hicuts" class="bibtex noshow">
				<td colspan="7"><b>BibTeX</b>:
					<pre>
@inproceedings{gupta1999hicuts,
  author = {Pankaj Gupta And and Pankaj Gupta and Nick Mckeown},
  title = {Packet Classification using Hierarchical Intelligent Cuttings},
  booktitle = {in Hot Interconnects VII},
  year = {1999},
  pages = {34--41},
  url = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.6.7809},
  doi = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.6.7809}
}
					</pre>
				</td>
			</tr><tr id="gupta1999rfc" class="entry">
				<td style="text-align: center;">gupta1999rfc</td>
				<td>
					
						Gupta, P. &amp; McKeown, N.
					
					
					
				</td>
				<td>
					
					Packet classification on multiple fields
					
					<p class="infolinks">
						[<a href="javascript:toggleInfo('gupta1999rfc','abstract')">Abstract</a>] 
						[<a href="javascript:toggleInfo('gupta1999rfc','review')">Review</a>] 
						[<a href="javascript:toggleInfo('gupta1999rfc','bibtex')">BibTeX</a>] 
						[<a href="http://portal.acm.org/citation.cfm?id=316188.316217#">URL</a>]
						
						[<a href="http://portal.acm.org/ft_gateway.cfm?id=316217&type=pdf&coll=GUIDE&dl=GUIDE&CFID=81255611&CFTOKEN=12152430">PDF</a>]
					</p>
				</td>
				<td style="text-align: center;">1999</td>
				<td>
					    SIGCOMM '99: Proceedings of the conference on Applications, technologies, architectures, and protocols for computer communication , pp. 147-160  &nbsp;
				</td>
				<td>inproceedings</td>
				<td></td>
			</tr>
			<tr id="abs_gupta1999rfc" class="abstract noshow">
				<td colspan="7"><b>Abstract</b>: Routers classify packets to determine which flow they belong to, and to decide what service they should receive. Classification may, in general, be based on an arbitrary number of fields in the packet header. Performing classification quickly on an arbitrary number of fields is known to be difficult, and has poor worst-case performance. In this paper, we consider a number of classifiers taken from real networks. We find that the classifiers contain considerable structure and redundancy that can be exploited by the classification algorithm. In particular, we find that a simple multi-stage classification algorithm, called RFC (recursive flow classification), can classify 30 million packets per second in pipelined hardware, or one million packets per second in software.</td>
			</tr>
			<tr id="rev_gupta1999rfc" class="review noshow">
				<td colspan="7"><b>Review</b>: the RFC algorithm</td>
			</tr>
			<tr id="bib_gupta1999rfc" class="bibtex noshow">
				<td colspan="7"><b>BibTeX</b>:
					<pre>
@inproceedings{gupta1999rfc,
  author = {Gupta, Pankaj and McKeown, Nick},
  title = {Packet classification on multiple fields},
  booktitle = {SIGCOMM '99: Proceedings of the conference on Applications, technologies, architectures, and protocols for computer communication},
  publisher = {ACM},
  year = {1999},
  pages = {147--160},
  url = {http://portal.acm.org/citation.cfm?id=316188.316217#},
  doi = {http://doi.acm.org/10.1145/316188.316217}
}
					</pre>
				</td>
			</tr><tr id="Lakshminarayanan2005" class="entry">
				<td style="text-align: center;">Lakshminarayanan2005</td>
				<td>
					
						Lakshminarayanan, K.; Rangarajan, A. &amp; Venkatachary, S.
					
					
					
				</td>
				<td>
					
					Algorithms for advanced packet classification with ternary CAMs
					
					<p class="infolinks">
						[<a href="javascript:toggleInfo('Lakshminarayanan2005','abstract')">Abstract</a>] 
						
						[<a href="javascript:toggleInfo('Lakshminarayanan2005','bibtex')">BibTeX</a>] 
						[<a href="http://portal.acm.org/citation.cfm?id=1080115#">URL</a>]
						
						[<a href="http://portal.acm.org/ft_gateway.cfm?id=1080115&type=pdf&coll=GUIDE&dl=GUIDE&CFID=93479230&CFTOKEN=80969664">PDF</a>]
					</p>
				</td>
				<td style="text-align: center;">2005</td>
				<td>
					    SIGCOMM '05: Proceedings of the 2005 conference on Applications, technologies, architectures, and protocols for computer communications , pp. 193-204  &nbsp;
				</td>
				<td>inproceedings</td>
				<td></td>
			</tr>
			<tr id="abs_Lakshminarayanan2005" class="abstract noshow">
				<td colspan="7"><b>Abstract</b>: Ternary content-addressable memories (TCAMs) have gained wide acceptance in the industry for storing and searching Access Control Lists (ACLs). In this paper, we propose algorithms for addressing two important problems that are encountered while using TCAMs: reducing range expansion and multi-match classification.Our first algorithm addresses the problem of expansion of rules with range fields¿to represent range rules in TCAMs, a single range rule is mapped to multiple TCAM entries, which reduces the utilization of TCAMs. We propose a new scheme called Database Independent Range PreEncoding (DIRPE) that, in comparison to earlier approaches, reduces the worst-case number of TCAM entries a single rule maps on to. DIRPE works without prior knowledge of the database, scales when a large number of ranges is present, and has good incremental update properties.Our second algorithm addresses the problem of finding multiple matches in a TCAM. When searched, TCAMs return the first matching entry; however, new applications require either the first few or all matching entries. We describe a novel algorithm, called Multi-match Using Discriminators (MUD), that finds multiple matches without storing any per-search state information in the TCAM, thus making it suitable for multi-threaded environments. MUD does not increase the number of TCAM entries needed, and hence scales to large databases.Our algorithms do not require any modifications to existing TCAMs and are hence relatively easy to deploy. We evaluate the algorithms using real-life and random databases.</td>
			</tr>
			<tr id="bib_Lakshminarayanan2005" class="bibtex noshow">
				<td colspan="7"><b>BibTeX</b>:
					<pre>
@inproceedings{Lakshminarayanan2005,
  author = {Lakshminarayanan, Karthik and Rangarajan, Anand and Venkatachary, Srinivasan},
  title = {Algorithms for advanced packet classification with ternary CAMs},
  booktitle = {SIGCOMM '05: Proceedings of the 2005 conference on Applications, technologies, architectures, and protocols for computer communications},
  publisher = {ACM},
  year = {2005},
  pages = {193--204},
  url = {http://portal.acm.org/citation.cfm?id=1080115#},
  doi = {http://doi.acm.org/10.1145/1080091.1080115}
}
					</pre>
				</td>
			</tr><tr id="liu2006high-performance" class="entry">
				<td style="text-align: center;">liu2006high-performance</td>
				<td>
					
						Liu, D.; Hua, B.; Hu, X. &amp; Tang, X.
					
					
					
				</td>
				<td>
					
					High-performance packet classification algorithm for many-core and multithreaded network processor
					
					<p class="infolinks">
						[<a href="javascript:toggleInfo('liu2006high-performance','abstract')">Abstract</a>] 
						
						[<a href="javascript:toggleInfo('liu2006high-performance','bibtex')">BibTeX</a>] 
						[<a href="http://portal.acm.org/citation.cfm?id=1176760.1176801#">URL</a>]
						
						[<a href="http://portal.acm.org/ft_gateway.cfm?id=1176801&type=pdf&coll=GUIDE&dl=GUIDE&CFID=81260757&CFTOKEN=30567210">PDF</a>]
					</p>
				</td>
				<td style="text-align: center;">2006</td>
				<td>
					    CASES '06: Proceedings of the 2006 international conference on Compilers, architecture and synthesis for embedded systems , pp. 334-344  &nbsp;
				</td>
				<td>inproceedings</td>
				<td></td>
			</tr>
			<tr id="abs_liu2006high-performance" class="abstract noshow">
				<td colspan="7"><b>Abstract</b>: Packet classification is crucial for the Internet to provide more value-added services and guaranteed quality of service. Besides hardware-based solutions, many software-based classification algorithms have been proposed. However, classifying at 10Gbps speed or higher is a challenging problem and it is still one of the performance bottlenecks in core routers. In general, classification algorithms face the same challenge of balancing between high classification speed and low memory requirements. This paper proposes a modified Recursive Flow Classification (RFC) algorithm, Bitmap-RFC, which significantly reduces the memory requirements of RFC by applying a bitmap compression technique. To speed up classifying speed, we experiment on exploiting the architectural features of a many-core and multithreaded architecture from algorithm design to algorithm implementation. As a result, Bitmap-RFC strikes a good balance between speed and space. It can not only keep high classification speed but also reduce memory space significantly.This paper investigates the main NPU software design aspects that have dramatic performance impacts on any NPU-based implementations: memory space reduction, instruction selection, data allocation, task partitioning, and latency hiding. We experiment with an architecture-aware design principle to guarantee the high performance of the classification algorithm on an NPU implementation. The experimental results show that the Bitmap-RFC algorithm achieves 10Gbps speed or higher and has a good scalability on Intel IXP2800 NP.</td>
			</tr>
			<tr id="bib_liu2006high-performance" class="bibtex noshow">
				<td colspan="7"><b>BibTeX</b>:
					<pre>
@inproceedings{liu2006high-performance,
  author = {Liu, Duo and Hua, Bei and Hu, Xianghui and Tang, Xinan},
  title = {High-performance packet classification algorithm for many-core and multithreaded network processor},
  booktitle = {CASES '06: Proceedings of the 2006 international conference on Compilers, architecture and synthesis for embedded systems},
  publisher = {ACM},
  year = {2006},
  pages = {334--344},
  url = {http://portal.acm.org/citation.cfm?id=1176760.1176801#},
  doi = {http://doi.acm.org/10.1145/1176760.1176801}
}
					</pre>
				</td>
			</tr><tr id="Myers1999" class="entry">
				<td style="text-align: center;">Myers1999</td>
				<td>
					
						Myers, A.C.
					
					
					
				</td>
				<td>
					
					JFlow: practical mostly-static information flow control
					
					<p class="infolinks">
						
						
						[<a href="javascript:toggleInfo('Myers1999','bibtex')">BibTeX</a>] 
						[<a href="http://portal.acm.org/citation.cfm?id=292540.292561&type=series#">URL</a>]
						
						[<a href="http://portal.acm.org/ft_gateway.cfm?id=292561&type=pdf&coll=GUIDE&dl=GUIDE&CFID=91470705&CFTOKEN=88640879">PDF</a>]
					</p>
				</td>
				<td style="text-align: center;">1999</td>
				<td>
					    POPL '99: Proceedings of the 26th ACM SIGPLAN-SIGACT symposium on Principles of programming languages , pp. 228-241  &nbsp;
				</td>
				<td>inproceedings</td>
				<td></td>
			</tr>
			<tr id="bib_Myers1999" class="bibtex noshow">
				<td colspan="7"><b>BibTeX</b>:
					<pre>
@inproceedings{Myers1999,
  author = {Myers, Andrew C.},
  title = {JFlow: practical mostly-static information flow control},
  booktitle = {POPL '99: Proceedings of the 26th ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
  publisher = {ACM},
  year = {1999},
  pages = {228--241},
  url = {http://portal.acm.org/citation.cfm?id=292540.292561&amp;type=series#},
  doi = {http://doi.acm.org/10.1145/292540.292561}
}
					</pre>
				</td>
			</tr><tr id="overmars1994range" class="entry">
				<td style="text-align: center;">overmars1994range</td>
				<td>
					
						Overmars, M. &amp; van der Stappen, A.
					
					
					
				</td>
				<td>
					
					Range searching and point location among fat objects
					
					<p class="infolinks">
						[<a href="javascript:toggleInfo('overmars1994range','abstract')">Abstract</a>] 
						
						[<a href="javascript:toggleInfo('overmars1994range','bibtex')">BibTeX</a>] 
						[<a href="http://www.springerlink.com/content/l816452237850u7h/">URL</a>]
						
						[<a href="http://www.cs.uu.nl/pub/RUU/CS/techreps/CS-1994/1994-30.pdf">PDF</a>]
					</p>
				</td>
				<td style="text-align: center;">1994</td>
				<td>
					Algorithms—ESA'94     , pp. 240-253  &nbsp;
				</td>
				<td>article</td>
				<td></td>
			</tr>
			<tr id="abs_overmars1994range" class="abstract noshow">
				<td colspan="7"><b>Abstract</b>: We present a data structure that can store a set of disjoint fat objects in 2- and 3-space such that point location and bounded-size range searching with arbitrarily shaped regions can be performed efficiently. The structure can deal with either arbitrary (fat) convex objects or non-convex polygonal/polyhedral objects. For dimension d=2,3, the multi-purpose data structure supports point location and range searching queries in time O(logd−1 n) and requires O(n log d−1 n) storage, after O(n log d−1 n log log n) preprocessing. The data structure and query algorithm are rather simple. The results are likely to be extendible in many directions.</td>
			</tr>
			<tr id="bib_overmars1994range" class="bibtex noshow">
				<td colspan="7"><b>BibTeX</b>:
					<pre>
@article{overmars1994range,
  author = {Overmars, M. and van der Stappen, A.},
  title = {Range searching and point location among fat objects},
  journal = {Algorithms—ESA'94},
  publisher = {Springer},
  year = {1994},
  pages = {240--253},
  url = {http://www.springerlink.com/content/l816452237850u7h/},
  doi = {http://dx.doi.org/10.1007/BFb0049412}
}
					</pre>
				</td>
			</tr><tr id="qi2009packet" class="entry">
				<td style="text-align: center;">qi2009packet</td>
				<td>
					
						Qi, Y.; Xu, L.; Yang, B.; Xue, Y. &amp; Li, J.
					
					
					
				</td>
				<td>
					
					Packet Classification Algorithms: From Theory to Practice
					
					<p class="infolinks">
						[<a href="javascript:toggleInfo('qi2009packet','abstract')">Abstract</a>] 
						
						[<a href="javascript:toggleInfo('qi2009packet','bibtex')">BibTeX</a>] 
						[<a href="http://ieeexplore.ieee.org/search/srchabstract.jsp?tp=&arnumber=5061972&queryText%3DPacket+Classification+Algorithms:+From+Theory+to+Practice%26openedRefinements%3D*%26searchField%3DSearch+All">URL</a>]
						
						[<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=5061972">PDF</a>]
					</p>
				</td>
				<td style="text-align: center;">2009</td>
				<td>
					INFOCOM 2009, IEEE     , pp. 648 -656  &nbsp;
				</td>
				<td>inproceedings</td>
				<td>hsm algorithms;hicuts;hypersplit;classification speed;mathematical analysis;memory usage;packet classification algorithms;preprocessing time;software simulation;internet;pattern classification;security of data;</td>
			</tr>
			<tr id="abs_qi2009packet" class="abstract noshow">
				<td colspan="7"><b>Abstract</b>: During the past decade, the packet classification problem has been widely studied to accelerate network applications such as access control, traffic engineering and intrusion detection. In our research, we found that although a great number of packet classification algorithms have been proposed in recent years, unfortunately most of them stagnate in mathematical analysis or software simulation stages and few of them have been implemented in commercial products as a generic solution. To fill the gap between theory and practice, in this paper, we propose a novel packet classification algorithm named HyperSplit. Compared to the well-known HiCuts and HSM algorithms, HyperSplit achieves superior performance in terms of classification speed, memory usage and preprocessing time. The practicability of the proposed algorithm is manifested by two facts in our test: HyperSplit is the only algorithm that can successfully handle all the rule sets; HyperSplit is also the only algorithm that reaches more than 6Gbps throughput on the Octeon3860 multi-core platform when tested with 64-byte Ethernet packets against 10K ACL rules.</td>
			</tr>
			<tr id="bib_qi2009packet" class="bibtex noshow">
				<td colspan="7"><b>BibTeX</b>:
					<pre>
@inproceedings{qi2009packet,
  author = {Yaxuan Qi and Lianghong Xu and Baohua Yang and Yibo Xue and Jun Li},
  title = {Packet Classification Algorithms: From Theory to Practice},
  journal = {INFOCOM 2009, IEEE},
  year = {2009},
  pages = {648 -656},
  url = {http://ieeexplore.ieee.org/search/srchabstract.jsp?tp=&amp;arnumber=5061972&amp;queryText%3DPacket+Classification+Algorithms:+From+Theory+to+Practice%26openedRefinements%3D*%26searchField%3DSearch+All},
  doi = {http://dx.doi.org/10.1109/INFCOM.2009.5061972}
}
					</pre>
				</td>
			</tr><tr id="singh2003packet" class="entry">
				<td style="text-align: center;">singh2003packet</td>
				<td>
					
						Singh, S.; Baboescu, F.; Varghese, G. &amp; Wang, J.
					
					
					
				</td>
				<td>
					
					Packet classification using multidimensional cutting
					
					<p class="infolinks">
						[<a href="javascript:toggleInfo('singh2003packet','abstract')">Abstract</a>] 
						[<a href="javascript:toggleInfo('singh2003packet','review')">Review</a>] 
						[<a href="javascript:toggleInfo('singh2003packet','bibtex')">BibTeX</a>] 
						[<a href="http://portal.acm.org/citation.cfm?id=863980&dl=#">URL</a>]
						
						[<a href="http://portal.acm.org/ft_gateway.cfm?id=863980&type=pdf&coll=GUIDE&dl=&CFID=81260579&CFTOKEN=28010347">PDF</a>]
					</p>
				</td>
				<td style="text-align: center;">2003</td>
				<td>
					    SIGCOMM '03: Proceedings of the 2003 conference on Applications, technologies, architectures, and protocols for computer communications , pp. 213-224  &nbsp;
				</td>
				<td>inproceedings</td>
				<td></td>
			</tr>
			<tr id="abs_singh2003packet" class="abstract noshow">
				<td colspan="7"><b>Abstract</b>: This paper introduces a classification algorithm called phHyperCuts. Like the previously best known algorithm, HiCuts, HyperCuts is based on a decision tree structure. Unlike HiCuts, however, in which each node in the decision tree represents a hyperplane, each node in the HyperCuts decision tree represents a k--dimensional hypercube. Using this extra degree of freedom and a new set of heuristics to find optimal hypercubes for a given amount of storage, HyperCuts can provide an order of magnitude improvement over existing classification algorithms. HyperCuts uses 2 to 10 times less memory than HiCuts optimized for memory, while the worst case search time of HyperCuts is 50--500% better than that of HiCuts optimized for speed. Compared with another recent scheme, EGT-PC, HyperCuts uses 1.8--7 times less memory space while the worst case search time is up to 5 times smaller. More importantly, unlike EGT-PC, HyperCuts can be fully pipelined to provide one classification result every packet arrival time, and also allows fast updates.</td>
			</tr>
			<tr id="rev_singh2003packet" class="review noshow">
				<td colspan="7"><b>Review</b>: HyperCuts</td>
			</tr>
			<tr id="bib_singh2003packet" class="bibtex noshow">
				<td colspan="7"><b>BibTeX</b>:
					<pre>
@inproceedings{singh2003packet,
  author = {Singh, Sumeet and Baboescu, Florin and Varghese, George and Wang, Jia},
  title = {Packet classification using multidimensional cutting},
  booktitle = {SIGCOMM '03: Proceedings of the 2003 conference on Applications, technologies, architectures, and protocols for computer communications},
  publisher = {ACM},
  year = {2003},
  pages = {213--224},
  url = {http://portal.acm.org/citation.cfm?id=863980&amp;dl=#},
  doi = {http://doi.acm.org/10.1145/863955.863980}
}
					</pre>
				</td>
			</tr><tr id="316216" class="entry">
				<td style="text-align: center;">316216</td>
				<td>
					
						Srinivasan, V.; Suri, S. &amp; Varghese, G.
					
					
					
				</td>
				<td>
					
					Packet classification using tuple space search
					
					<p class="infolinks">
						[<a href="javascript:toggleInfo('316216','abstract')">Abstract</a>] 
						
						[<a href="javascript:toggleInfo('316216','bibtex')">BibTeX</a>] 
						[<a href="http://portal.acm.org/citation.cfm?id=316216#">URL</a>]
						
						[<a href="http://portal.acm.org/ft_gateway.cfm?id=316216&type=pdf&coll=GUIDE&dl=GUIDE&CFID=81256800&CFTOKEN=69305471">PDF</a>]
					</p>
				</td>
				<td style="text-align: center;">1999</td>
				<td>
					    SIGCOMM '99: Proceedings of the conference on Applications, technologies, architectures, and protocols for computer communication , pp. 135-146  &nbsp;
				</td>
				<td>inproceedings</td>
				<td></td>
			</tr>
			<tr id="abs_316216" class="abstract noshow">
				<td colspan="7"><b>Abstract</b>: Routers must perform packet classification at high speeds to efficiently implement functions such as firewalls and QoS routing. Packet classification requires matching each packet against a database of filters (or rules), and forwarding the packet according to the highest priority filter. Existing filter schemes with fast lookup time do not scale to large filter databases. Other more scalable schemes work for 2-dimensional filters, but their lookup times degrade quickly with each additional dimension. While there exist good hardware solutions, our new schemes are geared towards software implementation.We introduce a generic packet classification algorithm, called Tuple Space Search (TSS). Because real databases typically use only a small number of distinct field lengths, by mapping filters to tuples even a simple linear search of the tuple space can provide significant speedup over naive linear search over the filters. Each tuple is maintained as a hash table that can be searched in one memory access. We then introduce techniques for further refining the search of the tuple space, and demonstrate their effectiveness on some firewall databases. For example, a real database of 278 filters had a tuple space of 41 which our algorithm prunes to 11 tuples. Even as we increased the filter database size from 1K to 100K (using a random two-dimensional filter generation model), the number of tuples grew from 53 to only 186, and the pruned tuples only grew from 1 to 4. Our Pruned Tuple Space search is also the only scheme known to us that allows fast updates and fast search times. We also show a lower bound on the general tuple space search problem, and describe an optimal algorithm, called Rectangle Search, for two-dimensional filters.</td>
			</tr>
			<tr id="bib_316216" class="bibtex noshow">
				<td colspan="7"><b>BibTeX</b>:
					<pre>
@inproceedings{316216,
  author = {Srinivasan, V. and Suri, S. and Varghese, G.},
  title = {Packet classification using tuple space search},
  booktitle = {SIGCOMM '99: Proceedings of the conference on Applications, technologies, architectures, and protocols for computer communication},
  publisher = {ACM},
  year = {1999},
  pages = {135--146},
  url = {http://portal.acm.org/citation.cfm?id=316216#},
  doi = {http://doi.acm.org/10.1145/316188.316216}
}
					</pre>
				</td>
			</tr><tr id="taylor2005survey" class="entry">
				<td style="text-align: center;">taylor2005survey</td>
				<td>
					
						Taylor, D.E.
					
					
					
				</td>
				<td>
					
					Survey and taxonomy of packet classification techniques
					
					<p class="infolinks">
						[<a href="javascript:toggleInfo('taylor2005survey','abstract')">Abstract</a>] 
						
						[<a href="javascript:toggleInfo('taylor2005survey','bibtex')">BibTeX</a>] 
						[<a href="http://portal.acm.org/citation.cfm?id=1108956.1108958&coll=GUIDE&dl=GUIDE&CFID=81255611&CFTOKEN=12152430#">URL</a>]
						
						[<a href="http://portal.acm.org/ft_gateway.cfm?id=1108958&type=pdf&coll=GUIDE&dl=GUIDE&CFID=81255611&CFTOKEN=12152430">PDF</a>]
					</p>
				</td>
				<td style="text-align: center;">2005</td>
				<td>
					ACM Computing Surveys (CSUR)  <br/>Vol. 37 (3)  , pp. 238-275  &nbsp;
				</td>
				<td>inproceedings</td>
				<td></td>
			</tr>
			<tr id="abs_taylor2005survey" class="abstract noshow">
				<td colspan="7"><b>Abstract</b>: Packet classification is an enabling function for a variety of Internet applications including quality of service, security, monitoring, and multimedia communications. In order to classify a packet as belonging to a particular flow or set of flows, network nodes must perform a search over a set of filters using multiple fields of the packet as the search key. In general, there have been two major threads of research addressing packet classification, algorithmic and architectural. A few pioneering groups of researchers posed the problem, provided complexity bounds, and offered a collection of algorithmic solutions. Subsequently, the design space has been vigorously explored by many offering new algorithms and improvements on existing algorithms. Given the inability of early algorithms to meet performance constraints imposed by high speed links, researchers in industry and academia devised architectural solutions to the problem. This thread of research produced the most widely-used packet classification device technology, Ternary Content Addressable Memory (TCAM). New architectural research combines intelligent algorithms and novel architectures to eliminate many of the unfavorable characteristics of current TCAMs. We observe that the community appears to be converging on a combined algorithmic and architectural approach to the problem. Using a taxonomy based on the high-level approach to the problem and a minimal set of running examples, we provide a survey of the seminal and recent solutions to the problem. It is our hope to foster a deeper understanding of the various packet classification techniques while providing a useful framework for discerning relationships and distinctions.</td>
			</tr>
			<tr id="bib_taylor2005survey" class="bibtex noshow">
				<td colspan="7"><b>BibTeX</b>:
					<pre>
@inproceedings{taylor2005survey,
  author = {Taylor, David E.},
  title = {Survey and taxonomy of packet classification techniques},
  journal = {ACM Computing Surveys (CSUR)},
  publisher = {ACM},
  year = {2005},
  volume = {37},
  number = {3},
  pages = {238--275},
  url = {http://portal.acm.org/citation.cfm?id=1108956.1108958&amp;coll=GUIDE&amp;dl=GUIDE&amp;CFID=81255611&amp;CFTOKEN=12152430#},
  doi = {http://doi.acm.org/10.1145/1108956.1108958}
}
					</pre>
				</td>
			</tr><tr id="taylor2007classbench" class="entry">
				<td style="text-align: center;">taylor2007classbench</td>
				<td>
					
						Taylor, D.E. &amp; Turner, J.S.
					
					
					
				</td>
				<td>
					
					ClassBench: a packet classification benchmark
					
					<p class="infolinks">
						[<a href="javascript:toggleInfo('taylor2007classbench','abstract')">Abstract</a>] 
						
						[<a href="javascript:toggleInfo('taylor2007classbench','bibtex')">BibTeX</a>] 
						[<a href="http://portal.acm.org/citation.cfm?id=1295237.1295239#">URL</a>]
						
						[<a href="http://portal.acm.org/ft_gateway.cfm?id=1295239&type=pdf&coll=GUIDE&dl=GUIDE&CFID=81261132&CFTOKEN=63868935">PDF</a>]
					</p>
				</td>
				<td style="text-align: center;">2007</td>
				<td>
					IEEE/ACM Transactions on Networking (TON)  <br/>Vol. 15 (3)  , pp. 499-511  &nbsp;
				</td>
				<td>article</td>
				<td></td>
			</tr>
			<tr id="abs_taylor2007classbench" class="abstract noshow">
				<td colspan="7"><b>Abstract</b>: Packet classification is an enabling technology for next generation network services and often a performance bottleneck in high-performance routers. The performance and capacity of many classification algorithms and devices, including TCAMs, depend upon properties of filter sets and query patterns. Despite the pressing need, no standard performance evaluation tools or filter sets are publicly available. In response to this problem, we present ClassBench, a suite of tools for benchmarking packet classification algorithms and devices. ClassBench includes a Filter Set Generator that produces synthetic filter sets that accurately model the characteristics of real filter sets. Along with varying the size of the filter sets, we provide high-level control over the composition of the filters in the resulting filter set. The tool suite also includes a Trace Generator that produces a sequence of packet headers to exercise packet classification algorithms with respect to a given filter set. Along with specifying the relative size of the trace, we provide a simple mechanism for controlling locality of reference. While we have already found ClassBench to be very useful in our own research, we seek to eliminate the significant access barriers to realistic test vectors for researchers and initiate a broader discussion to guide the refinement of the tools and codification of a formal benchmarking methodology. (The ClassBench tools are publicly available at the following site: http://www.arl.wustl.edu/~det3/ClassBench/.)</td>
			</tr>
			<tr id="bib_taylor2007classbench" class="bibtex noshow">
				<td colspan="7"><b>BibTeX</b>:
					<pre>
@article{taylor2007classbench,
  author = {Taylor, David E. and Turner, Jonathan S.},
  title = {ClassBench: a packet classification benchmark},
  journal = {IEEE/ACM Transactions on Networking (TON)},
  publisher = {IEEE Press},
  year = {2007},
  volume = {15},
  number = {3},
  pages = {499--511},
  url = {http://portal.acm.org/citation.cfm?id=1295237.1295239#},
  doi = {http://dx.doi.org/10.1109/TNET.2007.893156}
}
					</pre>
				</td>
			</tr><tr id="woo2000modular" class="entry">
				<td style="text-align: center;">woo2000modular</td>
				<td>
					
						Woo, T.Y.C.
					
					
					
				</td>
				<td>
					
					A Modular Approach to Packet Classification: Algorithms and Results
					
					<p class="infolinks">
						[<a href="javascript:toggleInfo('woo2000modular','abstract')">Abstract</a>] 
						
						[<a href="javascript:toggleInfo('woo2000modular','bibtex')">BibTeX</a>] 
						[<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=832499&userType=inst">URL</a>]
						
						[<a href="http://ieeexplore.ieee.org/iel5/6725/17999/00832499.pdf">PDF</a>]
					</p>
				</td>
				<td style="text-align: center;">2000</td>
				<td>
					    In IEEE Infocom , pp. 1213-1222  &nbsp;
				</td>
				<td>inproceedings</td>
				<td></td>
			</tr>
			<tr id="abs_woo2000modular" class="abstract noshow">
				<td colspan="7"><b>Abstract</b>: The ability to classify packets according to pre-defined rules is critical to providing many sophisticated value-added services, such as security, QoS, load balancing, traffic accounting, etc. Various approaches to packet classification have been studied in the literature with accompanying theoretical bounds. Practical studies with results applying to large number of filters (from 8K to 1 million) are rare. In this paper, we take a practical approach to the problem of packet classification. Specifically, we propose and study a novel approach to packet classification which combines heuristic tree search with the use of filter buckets. Besides high performance and reasonable storage requirement, our algorithm is unique in the sense that it can adapt to the input packet distribution by taking into account the relative filter usage. To evaluate our algorithms, we have developed realistic models of large scale filter tables, and used them to drive extensive experimentation. The results demonstrate practicality of our algorithms for even up to 1 million filters.</td>
			</tr>
			<tr id="bib_woo2000modular" class="bibtex noshow">
				<td colspan="7"><b>BibTeX</b>:
					<pre>
@inproceedings{woo2000modular,
  author = {Thomas Y. C. Woo},
  title = {A Modular Approach to Packet Classification: Algorithms and Results},
  booktitle = {In IEEE Infocom},
  year = {2000},
  pages = {1213--1222},
  url = {http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=832499&amp;userType=inst},
  doi = {http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.4744}
}
					</pre>
				</td>
			</tr><tr id="xu2005hsm" class="entry">
				<td style="text-align: center;">xu2005hsm</td>
				<td>
					
						Xu, B.; Jiang, D. &amp; Li, J.
					
					
					
				</td>
				<td>
					
					HSM: A fast packet classification algorithm
					
					<p class="infolinks">
						[<a href="javascript:toggleInfo('xu2005hsm','abstract')">Abstract</a>] 
						[<a href="javascript:toggleInfo('xu2005hsm','review')">Review</a>] 
						[<a href="javascript:toggleInfo('xu2005hsm','bibtex')">BibTeX</a>] 
						[<a href="http://portal.acm.org/citation.cfm?id=1058422.1058607">URL</a>]
						
						[<a href="http://security.riit.tsinghua.edu.cn/share/HSM.pdf">PDF</a>]
					</p>
				</td>
				<td style="text-align: center;">2005</td>
				<td>
					  <br/>Vol. 1  Advanced Information Networking and Applications, 2005. AINA 2005. 19th International Conference on   &nbsp;
				</td>
				<td>conference</td>
				<td></td>
			</tr>
			<tr id="abs_xu2005hsm" class="abstract noshow">
				<td colspan="7"><b>Abstract</b>: Packet classification on multiple header fields is one of the basic techniques used in network devices such as routers and firewalls, and usually the most computation intensive task among others. To determine what action needs to be taken to a packet, a network device responsible for packet classification must identify the packetýs property, such as associated packet flow, based on multiple fields of its header. Fast packet classification on multiple fields is known to be difficult mathematically and expensive practically. In this paper, we describe and discuss a fast packet classification algorithm using a multiple stage reduction scheme similar to the previously well-know Recursive Flow Classification (RFC) algorithm. The proposed Hierarchical Space Mapping (HSM) algorithm requires much less memory usage than RFC while keeps average search time on the same order. HSM has been proved to be very effective with commercial products in real networks.</td>
			</tr>
			<tr id="rev_xu2005hsm" class="review noshow">
				<td colspan="7"><b>Review</b>: #HSM#</td>
			</tr>
			<tr id="bib_xu2005hsm" class="bibtex noshow">
				<td colspan="7"><b>BibTeX</b>:
					<pre>
@conference{xu2005hsm,
  author = {Xu, B. and Jiang, D. and Li, J.},
  title = {HSM: A fast packet classification algorithm},
  booktitle = {Advanced Information Networking and Applications, 2005. AINA 2005. 19th International Conference on},
  year = {2005},
  volume = {1},
  url = {http://portal.acm.org/citation.cfm?id=1058422.1058607}
}
					</pre>
				</td>
			</tr><tr id="yang2009dbs:" class="entry">
				<td style="text-align: center;">yang2009dbs:</td>
				<td>
					
						Yang, B.; Wang, X.; Xue, Y. &amp; Li, J.
					
					
					
				</td>
				<td>
					
					DBS: A Bit-level Heuristic Packet Classification Algorithm for High Speed Network
					
					<p class="infolinks">
						[<a href="javascript:toggleInfo('yang2009dbs:','abstract')">Abstract</a>] 
						
						[<a href="javascript:toggleInfo('yang2009dbs:','bibtex')">BibTeX</a>] 
						[<a href="http://portal.acm.org/citation.cfm?id=1728720#">URL</a>]
						
						[<a href="http://security.riit.tsinghua.edu.cn/share/dbs_bhyang.pdf">PDF</a>]
					</p>
				</td>
				<td style="text-align: center;">2009</td>
				<td>
					    ICPADS '09: Proceedings of the 2009 15th International Conference on Parallel and Distributed Systems , pp. 260-267  &nbsp;
				</td>
				<td>article</td>
				<td></td>
			</tr>
			<tr id="abs_yang2009dbs:" class="abstract noshow">
				<td colspan="7"><b>Abstract</b>: Packet classification is one of the most critical techniques in many network devices such as Firewall, IDS and IPS, etc. In order to meet the performance requirement for high speed Internet (even higher than 10 Gbps), practical algorithms must keep better spatial and temporal performance. Moreover, as the size of rule set is increasing to tens of thousands, novel packet classification algorithms must have good scalability. In this paper, we propose a novel packet classification algorithm named DBS (Discrete Bit Selection) which takes a bit level heuristic design to partition the rule set effectively. To the best of our knowledge, DBS is the first try to design a heuristic classification algorithm at bit-level. To evaluate the performance of our algorithm, DBS is deployed on a popular multi-core Network Processor platform, compared with two existing well-known algorithms. Experimental results show that DBS achieves 300% higher throughput than HiCuts and HSM, while the memory requirement is reduced to about 10% averagely. DBS works well especially with large rule set (10K), which trends a good scalability.</td>
			</tr>
			<tr id="bib_yang2009dbs:" class="bibtex noshow">
				<td colspan="7"><b>BibTeX</b>:
					<pre>
@article{yang2009dbs:,
  author = {Yang, Baohua and Wang, Xiang and Xue, Yibo and Li, Jun},
  title = {DBS: A Bit-level Heuristic Packet Classification Algorithm for High Speed Network},
  booktitle = {ICPADS '09: Proceedings of the 2009 15th International Conference on Parallel and Distributed Systems},
  publisher = {IEEE Computer Society},
  year = {2009},
  pages = {260--267},
  url = {http://portal.acm.org/citation.cfm?id=1728720#},
  doi = {http://dx.doi.org/10.1109/ICPADS.2009.53}
}
					</pre>
				</td>
			</tr><tr id="Zheng2005" class="entry">
				<td style="text-align: center;">Zheng2005</td>
				<td>
					
						Zheng, K.; Che, H.; Wang, Z. &amp; Liu, B.
					
					
					
				</td>
				<td>
					
					TCAM-based distributed parallel packet classification algorithm with range-matching solution
					
					<p class="infolinks">
						[<a href="javascript:toggleInfo('Zheng2005','abstract')">Abstract</a>] 
						
						[<a href="javascript:toggleInfo('Zheng2005','bibtex')">BibTeX</a>] 
						[<a href="http://ieeexplore.ieee.org/search/srchabstract.jsp?tp=&arnumber=1497900&queryText%3DTCAM-based+Distributed+Parallel+Packet+Classification+Algorithm+with+Range-Matching+Solution%26openedRefinements%3D*%26searchField%3DSearch+All">URL</a>]
						
						[<a href="http://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=1497900">PDF</a>]
					</p>
				</td>
				<td style="text-align: center;">2005</td>
				<td>
					  <br/>Vol. 1  INFOCOM 2005. 24th Annual Joint Conference of the IEEE Computer and Communications Societies. Proceedings IEEE , pp.  293 - 303 vol. 1  &nbsp;
				</td>
				<td>inproceedings</td>
				<td> 40 gbit/s; chip-level-parallelism; critical data path function; distributed parallel packet classification algorithm; encoding scheme; range-matching solution; ternary content addressable memory; parallel algorithms; pattern classification; storage allocation; telecommunication traffic;</td>
			</tr>
			<tr id="abs_Zheng2005" class="abstract noshow">
				<td colspan="7"><b>Abstract</b>: Packet classification (PC) has been a critical data path function for many emerging networking applications. An interesting approach is the use of TCAM to achieve deterministic, high speed PC However, apart from high cost and power consumption, due to slow growing clock rate for memory technology in general, PC based on the traditional single TCAM solution has difficulty to keep up with fast growing line rates. Moreover, the TCAM storage efficiency is largely affected by the need to support rules with ranges, or range matching. In this paper, a distributed TCAM scheme that exploits chip-level-parallelism is proposed to greatly improve the PC throughput. This scheme seamlessly integrates with a range encoding scheme, which not only solves the range matching problem but also ensures a balanced high throughput performance. Using commercially available TCAM chips, the proposed scheme achieves PC performance of more than 100 million packets per second (Mpps), matching OC768 (40 Gbps) line rate.</td>
			</tr>
			<tr id="bib_Zheng2005" class="bibtex noshow">
				<td colspan="7"><b>BibTeX</b>:
					<pre>
@inproceedings{Zheng2005,
  author = {Kai Zheng and Hao Che and Zhijun Wang and Bin Liu},
  title = {TCAM-based distributed parallel packet classification algorithm with range-matching solution},
  booktitle = {INFOCOM 2005. 24th Annual Joint Conference of the IEEE Computer and Communications Societies. Proceedings IEEE},
  year = {2005},
  volume = {1},
  pages = { 293 - 303 vol. 1},
  url = {http://ieeexplore.ieee.org/search/srchabstract.jsp?tp=&amp;arnumber=1497900&amp;queryText%3DTCAM-based+Distributed+Parallel+Packet+Classification+Algorithm+with+Range-Matching+Solution%26openedRefinements%3D*%26searchField%3DSearch+All},
  doi = {http://dx.doi.org/10.1109/INFCOM.2005.1497900}
}
					</pre>
				</td>
			</tr></tbody>
	</table>

	<p>
		<small>Created on 01/11/2010. <a href="http://security.riit.tsinghua.edu.cn/~bhyang/paper_read.html">Return</a></small>
	</p>

	</body>
</html>
